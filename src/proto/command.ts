// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.0
// source: command.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import { Empty } from "./common";

export const protobufPackage = "cline";

/** Request to execute a command */
export interface ExecuteCommandRequest {
  /** The command to execute */
  command: string;
  /** The working directory */
  workingDirectory: string;
  /** Whether the command requires user approval */
  requireApproval: boolean;
}

/** Response from executing a command */
export interface ExecuteCommandResponse {
  /** Unique ID for the command execution */
  commandId: string;
  /** Initial output from the command */
  initialOutput: string;
  /** Whether the command is still running */
  isRunning: boolean;
}

/** Request to get command status */
export interface CommandStatusRequest {
  /** The ID of the command */
  commandId: string;
}

/** Response with command status */
export interface CommandStatusResponse {
  /** The ID of the command */
  commandId: string;
  /** Whether the command is still running */
  isRunning: boolean;
  /** Exit code if command has completed */
  exitCode: number;
  /** Current accumulated output */
  output: string;
  /** Error message if any */
  error: string;
}

/** Chunk of command output for streaming */
export interface CommandOutputChunk {
  /** The ID of the command */
  commandId: string;
  /** The chunk of output */
  outputChunk: string;
  /** Whether this chunk is from stderr */
  isStderr: boolean;
  /** Whether the command has completed */
  commandCompleted: boolean;
  /** Exit code if command has completed */
  exitCode: number;
}

/** Request to write input to a command's stdin */
export interface WriteCommandInputRequest {
  /** The ID of the command */
  commandId: string;
  /** The input to write */
  input: string;
  /** Whether to include a newline at the end */
  includeNewline: boolean;
}

function createBaseExecuteCommandRequest(): ExecuteCommandRequest {
  return { command: "", workingDirectory: "", requireApproval: false };
}

export const ExecuteCommandRequest: MessageFns<ExecuteCommandRequest> = {
  encode(message: ExecuteCommandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    if (message.workingDirectory !== "") {
      writer.uint32(18).string(message.workingDirectory);
    }
    if (message.requireApproval !== false) {
      writer.uint32(24).bool(message.requireApproval);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteCommandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteCommandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.workingDirectory = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.requireApproval = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteCommandRequest {
    return {
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      workingDirectory: isSet(object.workingDirectory) ? globalThis.String(object.workingDirectory) : "",
      requireApproval: isSet(object.requireApproval) ? globalThis.Boolean(object.requireApproval) : false,
    };
  },

  toJSON(message: ExecuteCommandRequest): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.workingDirectory !== "") {
      obj.workingDirectory = message.workingDirectory;
    }
    if (message.requireApproval !== false) {
      obj.requireApproval = message.requireApproval;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteCommandRequest>, I>>(base?: I): ExecuteCommandRequest {
    return ExecuteCommandRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteCommandRequest>, I>>(object: I): ExecuteCommandRequest {
    const message = createBaseExecuteCommandRequest();
    message.command = object.command ?? "";
    message.workingDirectory = object.workingDirectory ?? "";
    message.requireApproval = object.requireApproval ?? false;
    return message;
  },
};

function createBaseExecuteCommandResponse(): ExecuteCommandResponse {
  return { commandId: "", initialOutput: "", isRunning: false };
}

export const ExecuteCommandResponse: MessageFns<ExecuteCommandResponse> = {
  encode(message: ExecuteCommandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandId !== "") {
      writer.uint32(10).string(message.commandId);
    }
    if (message.initialOutput !== "") {
      writer.uint32(18).string(message.initialOutput);
    }
    if (message.isRunning !== false) {
      writer.uint32(24).bool(message.isRunning);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExecuteCommandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExecuteCommandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.initialOutput = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isRunning = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExecuteCommandResponse {
    return {
      commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "",
      initialOutput: isSet(object.initialOutput) ? globalThis.String(object.initialOutput) : "",
      isRunning: isSet(object.isRunning) ? globalThis.Boolean(object.isRunning) : false,
    };
  },

  toJSON(message: ExecuteCommandResponse): unknown {
    const obj: any = {};
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.initialOutput !== "") {
      obj.initialOutput = message.initialOutput;
    }
    if (message.isRunning !== false) {
      obj.isRunning = message.isRunning;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExecuteCommandResponse>, I>>(base?: I): ExecuteCommandResponse {
    return ExecuteCommandResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExecuteCommandResponse>, I>>(object: I): ExecuteCommandResponse {
    const message = createBaseExecuteCommandResponse();
    message.commandId = object.commandId ?? "";
    message.initialOutput = object.initialOutput ?? "";
    message.isRunning = object.isRunning ?? false;
    return message;
  },
};

function createBaseCommandStatusRequest(): CommandStatusRequest {
  return { commandId: "" };
}

export const CommandStatusRequest: MessageFns<CommandStatusRequest> = {
  encode(message: CommandStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandId !== "") {
      writer.uint32(10).string(message.commandId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandStatusRequest {
    return { commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "" };
  },

  toJSON(message: CommandStatusRequest): unknown {
    const obj: any = {};
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandStatusRequest>, I>>(base?: I): CommandStatusRequest {
    return CommandStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandStatusRequest>, I>>(object: I): CommandStatusRequest {
    const message = createBaseCommandStatusRequest();
    message.commandId = object.commandId ?? "";
    return message;
  },
};

function createBaseCommandStatusResponse(): CommandStatusResponse {
  return { commandId: "", isRunning: false, exitCode: 0, output: "", error: "" };
}

export const CommandStatusResponse: MessageFns<CommandStatusResponse> = {
  encode(message: CommandStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandId !== "") {
      writer.uint32(10).string(message.commandId);
    }
    if (message.isRunning !== false) {
      writer.uint32(16).bool(message.isRunning);
    }
    if (message.exitCode !== 0) {
      writer.uint32(24).int32(message.exitCode);
    }
    if (message.output !== "") {
      writer.uint32(34).string(message.output);
    }
    if (message.error !== "") {
      writer.uint32(42).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isRunning = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.output = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandStatusResponse {
    return {
      commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "",
      isRunning: isSet(object.isRunning) ? globalThis.Boolean(object.isRunning) : false,
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
      output: isSet(object.output) ? globalThis.String(object.output) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: CommandStatusResponse): unknown {
    const obj: any = {};
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.isRunning !== false) {
      obj.isRunning = message.isRunning;
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.output !== "") {
      obj.output = message.output;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandStatusResponse>, I>>(base?: I): CommandStatusResponse {
    return CommandStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandStatusResponse>, I>>(object: I): CommandStatusResponse {
    const message = createBaseCommandStatusResponse();
    message.commandId = object.commandId ?? "";
    message.isRunning = object.isRunning ?? false;
    message.exitCode = object.exitCode ?? 0;
    message.output = object.output ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseCommandOutputChunk(): CommandOutputChunk {
  return { commandId: "", outputChunk: "", isStderr: false, commandCompleted: false, exitCode: 0 };
}

export const CommandOutputChunk: MessageFns<CommandOutputChunk> = {
  encode(message: CommandOutputChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandId !== "") {
      writer.uint32(10).string(message.commandId);
    }
    if (message.outputChunk !== "") {
      writer.uint32(18).string(message.outputChunk);
    }
    if (message.isStderr !== false) {
      writer.uint32(24).bool(message.isStderr);
    }
    if (message.commandCompleted !== false) {
      writer.uint32(32).bool(message.commandCompleted);
    }
    if (message.exitCode !== 0) {
      writer.uint32(40).int32(message.exitCode);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandOutputChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandOutputChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outputChunk = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isStderr = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.commandCompleted = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandOutputChunk {
    return {
      commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "",
      outputChunk: isSet(object.outputChunk) ? globalThis.String(object.outputChunk) : "",
      isStderr: isSet(object.isStderr) ? globalThis.Boolean(object.isStderr) : false,
      commandCompleted: isSet(object.commandCompleted) ? globalThis.Boolean(object.commandCompleted) : false,
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
    };
  },

  toJSON(message: CommandOutputChunk): unknown {
    const obj: any = {};
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.outputChunk !== "") {
      obj.outputChunk = message.outputChunk;
    }
    if (message.isStderr !== false) {
      obj.isStderr = message.isStderr;
    }
    if (message.commandCompleted !== false) {
      obj.commandCompleted = message.commandCompleted;
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandOutputChunk>, I>>(base?: I): CommandOutputChunk {
    return CommandOutputChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandOutputChunk>, I>>(object: I): CommandOutputChunk {
    const message = createBaseCommandOutputChunk();
    message.commandId = object.commandId ?? "";
    message.outputChunk = object.outputChunk ?? "";
    message.isStderr = object.isStderr ?? false;
    message.commandCompleted = object.commandCompleted ?? false;
    message.exitCode = object.exitCode ?? 0;
    return message;
  },
};

function createBaseWriteCommandInputRequest(): WriteCommandInputRequest {
  return { commandId: "", input: "", includeNewline: false };
}

export const WriteCommandInputRequest: MessageFns<WriteCommandInputRequest> = {
  encode(message: WriteCommandInputRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandId !== "") {
      writer.uint32(10).string(message.commandId);
    }
    if (message.input !== "") {
      writer.uint32(18).string(message.input);
    }
    if (message.includeNewline !== false) {
      writer.uint32(24).bool(message.includeNewline);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteCommandInputRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteCommandInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.commandId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.input = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeNewline = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteCommandInputRequest {
    return {
      commandId: isSet(object.commandId) ? globalThis.String(object.commandId) : "",
      input: isSet(object.input) ? globalThis.String(object.input) : "",
      includeNewline: isSet(object.includeNewline) ? globalThis.Boolean(object.includeNewline) : false,
    };
  },

  toJSON(message: WriteCommandInputRequest): unknown {
    const obj: any = {};
    if (message.commandId !== "") {
      obj.commandId = message.commandId;
    }
    if (message.input !== "") {
      obj.input = message.input;
    }
    if (message.includeNewline !== false) {
      obj.includeNewline = message.includeNewline;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteCommandInputRequest>, I>>(base?: I): WriteCommandInputRequest {
    return WriteCommandInputRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteCommandInputRequest>, I>>(object: I): WriteCommandInputRequest {
    const message = createBaseWriteCommandInputRequest();
    message.commandId = object.commandId ?? "";
    message.input = object.input ?? "";
    message.includeNewline = object.includeNewline ?? false;
    return message;
  },
};

/** Command service for executing terminal commands */
export type CommandServiceService = typeof CommandServiceService;
export const CommandServiceService = {
  /** Execute a command in the specified directory */
  executeCommand: {
    path: "/cline.CommandService/ExecuteCommand",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExecuteCommandRequest) => Buffer.from(ExecuteCommandRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ExecuteCommandRequest.decode(value),
    responseSerialize: (value: ExecuteCommandResponse) => Buffer.from(ExecuteCommandResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ExecuteCommandResponse.decode(value),
  },
  /** Get status of a running command */
  getCommandStatus: {
    path: "/cline.CommandService/GetCommandStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CommandStatusRequest) => Buffer.from(CommandStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CommandStatusRequest.decode(value),
    responseSerialize: (value: CommandStatusResponse) => Buffer.from(CommandStatusResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CommandStatusResponse.decode(value),
  },
  /** Stream output from a running command */
  streamCommandOutput: {
    path: "/cline.CommandService/StreamCommandOutput",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: CommandStatusRequest) => Buffer.from(CommandStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CommandStatusRequest.decode(value),
    responseSerialize: (value: CommandOutputChunk) => Buffer.from(CommandOutputChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CommandOutputChunk.decode(value),
  },
  /** Kill a running command */
  killCommand: {
    path: "/cline.CommandService/KillCommand",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CommandStatusRequest) => Buffer.from(CommandStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CommandStatusRequest.decode(value),
    responseSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
  /** Write input to a running command's stdin */
  writeCommandInput: {
    path: "/cline.CommandService/WriteCommandInput",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WriteCommandInputRequest) => Buffer.from(WriteCommandInputRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WriteCommandInputRequest.decode(value),
    responseSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
} as const;

export interface CommandServiceServer extends UntypedServiceImplementation {
  /** Execute a command in the specified directory */
  executeCommand: handleUnaryCall<ExecuteCommandRequest, ExecuteCommandResponse>;
  /** Get status of a running command */
  getCommandStatus: handleUnaryCall<CommandStatusRequest, CommandStatusResponse>;
  /** Stream output from a running command */
  streamCommandOutput: handleServerStreamingCall<CommandStatusRequest, CommandOutputChunk>;
  /** Kill a running command */
  killCommand: handleUnaryCall<CommandStatusRequest, Empty>;
  /** Write input to a running command's stdin */
  writeCommandInput: handleUnaryCall<WriteCommandInputRequest, Empty>;
}

export interface CommandServiceClient extends Client {
  /** Execute a command in the specified directory */
  executeCommand(
    request: ExecuteCommandRequest,
    callback: (error: ServiceError | null, response: ExecuteCommandResponse) => void,
  ): ClientUnaryCall;
  executeCommand(
    request: ExecuteCommandRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ExecuteCommandResponse) => void,
  ): ClientUnaryCall;
  executeCommand(
    request: ExecuteCommandRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ExecuteCommandResponse) => void,
  ): ClientUnaryCall;
  /** Get status of a running command */
  getCommandStatus(
    request: CommandStatusRequest,
    callback: (error: ServiceError | null, response: CommandStatusResponse) => void,
  ): ClientUnaryCall;
  getCommandStatus(
    request: CommandStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CommandStatusResponse) => void,
  ): ClientUnaryCall;
  getCommandStatus(
    request: CommandStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CommandStatusResponse) => void,
  ): ClientUnaryCall;
  /** Stream output from a running command */
  streamCommandOutput(
    request: CommandStatusRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<CommandOutputChunk>;
  streamCommandOutput(
    request: CommandStatusRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<CommandOutputChunk>;
  /** Kill a running command */
  killCommand(
    request: CommandStatusRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  killCommand(
    request: CommandStatusRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  killCommand(
    request: CommandStatusRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  /** Write input to a running command's stdin */
  writeCommandInput(
    request: WriteCommandInputRequest,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  writeCommandInput(
    request: WriteCommandInputRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  writeCommandInput(
    request: WriteCommandInputRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
}

export const CommandServiceClient = makeGenericClientConstructor(
  CommandServiceService,
  "cline.CommandService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CommandServiceClient;
  service: typeof CommandServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
