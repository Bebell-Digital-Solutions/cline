// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.0
// source: search.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "cline";

/** Request to search files */
export interface SearchFilesRequest {
  /** Directory path to search in */
  path: string;
  /** Regular expression to search for */
  regex: string;
  /** File pattern (e.g., "*.ts", "*.go") */
  filePattern: string;
  /** Whether to search recursively */
  recursive: boolean;
  /** Number of context lines to include (default: 2) */
  contextLines: number;
}

/** Response from searching files */
export interface SearchFilesResponse {
  /** Search results */
  results: SearchResult[];
  /** Error message if any */
  error: string;
}

/** Individual search result */
export interface SearchResult {
  /** Path to the file where the match was found */
  filePath: string;
  /** Line number of the match */
  lineNumber: number;
  /** The matched text */
  matchText: string;
  /** The context surrounding the match */
  context: string;
  /** Start line of the context */
  startLine: number;
  /** End line of the context */
  endLine: number;
}

/** Request to list code definition names */
export interface CodeDefinitionRequest {
  /** Directory path to search in */
  path: string;
  /** File pattern (e.g., "*.ts", "*.go") */
  filePattern: string;
}

/** Response with code definition names */
export interface CodeDefinitionResponse {
  /** Code definitions */
  definitions: CodeDefinition[];
  /** Error message if any */
  error: string;
}

/** Individual code definition */
export interface CodeDefinition {
  /** Path to the file containing the definition */
  filePath: string;
  /** Name of the definition */
  name: string;
  /** Type of definition (function, class, etc.) */
  type: string;
  /** Line number of the definition */
  lineNumber: number;
  /** Signature of the definition */
  signature: string;
}

/** Request to replace text in a file */
export interface ReplaceInFileRequest {
  /** File path */
  path: string;
  /** Replacements to make */
  replacements: Replacement[];
}

/** Individual replacement */
export interface Replacement {
  /** Text to search for */
  search: string;
  /** Text to replace with */
  replace: string;
}

/** Response from replacing text in a file */
export interface ReplaceInFileResponse {
  /** Whether the replacement was successful */
  success: boolean;
  /** Error message if any */
  error: string;
  /** Number of replacements made */
  replacementsMade: number;
}

function createBaseSearchFilesRequest(): SearchFilesRequest {
  return { path: "", regex: "", filePattern: "", recursive: false, contextLines: 0 };
}

export const SearchFilesRequest: MessageFns<SearchFilesRequest> = {
  encode(message: SearchFilesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.regex !== "") {
      writer.uint32(18).string(message.regex);
    }
    if (message.filePattern !== "") {
      writer.uint32(26).string(message.filePattern);
    }
    if (message.recursive !== false) {
      writer.uint32(32).bool(message.recursive);
    }
    if (message.contextLines !== 0) {
      writer.uint32(40).int32(message.contextLines);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchFilesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchFilesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.regex = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.filePattern = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.recursive = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.contextLines = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchFilesRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      regex: isSet(object.regex) ? globalThis.String(object.regex) : "",
      filePattern: isSet(object.filePattern) ? globalThis.String(object.filePattern) : "",
      recursive: isSet(object.recursive) ? globalThis.Boolean(object.recursive) : false,
      contextLines: isSet(object.contextLines) ? globalThis.Number(object.contextLines) : 0,
    };
  },

  toJSON(message: SearchFilesRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.regex !== "") {
      obj.regex = message.regex;
    }
    if (message.filePattern !== "") {
      obj.filePattern = message.filePattern;
    }
    if (message.recursive !== false) {
      obj.recursive = message.recursive;
    }
    if (message.contextLines !== 0) {
      obj.contextLines = Math.round(message.contextLines);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchFilesRequest>, I>>(base?: I): SearchFilesRequest {
    return SearchFilesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchFilesRequest>, I>>(object: I): SearchFilesRequest {
    const message = createBaseSearchFilesRequest();
    message.path = object.path ?? "";
    message.regex = object.regex ?? "";
    message.filePattern = object.filePattern ?? "";
    message.recursive = object.recursive ?? false;
    message.contextLines = object.contextLines ?? 0;
    return message;
  },
};

function createBaseSearchFilesResponse(): SearchFilesResponse {
  return { results: [], error: "" };
}

export const SearchFilesResponse: MessageFns<SearchFilesResponse> = {
  encode(message: SearchFilesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      SearchResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchFilesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchFilesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(SearchResult.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchFilesResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => SearchResult.fromJSON(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: SearchFilesResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => SearchResult.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchFilesResponse>, I>>(base?: I): SearchFilesResponse {
    return SearchFilesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchFilesResponse>, I>>(object: I): SearchFilesResponse {
    const message = createBaseSearchFilesResponse();
    message.results = object.results?.map((e) => SearchResult.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseSearchResult(): SearchResult {
  return { filePath: "", lineNumber: 0, matchText: "", context: "", startLine: 0, endLine: 0 };
}

export const SearchResult: MessageFns<SearchResult> = {
  encode(message: SearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    if (message.lineNumber !== 0) {
      writer.uint32(16).int32(message.lineNumber);
    }
    if (message.matchText !== "") {
      writer.uint32(26).string(message.matchText);
    }
    if (message.context !== "") {
      writer.uint32(34).string(message.context);
    }
    if (message.startLine !== 0) {
      writer.uint32(40).int32(message.startLine);
    }
    if (message.endLine !== 0) {
      writer.uint32(48).int32(message.endLine);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.lineNumber = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.matchText = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.startLine = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.endLine = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResult {
    return {
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      lineNumber: isSet(object.lineNumber) ? globalThis.Number(object.lineNumber) : 0,
      matchText: isSet(object.matchText) ? globalThis.String(object.matchText) : "",
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      startLine: isSet(object.startLine) ? globalThis.Number(object.startLine) : 0,
      endLine: isSet(object.endLine) ? globalThis.Number(object.endLine) : 0,
    };
  },

  toJSON(message: SearchResult): unknown {
    const obj: any = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.lineNumber !== 0) {
      obj.lineNumber = Math.round(message.lineNumber);
    }
    if (message.matchText !== "") {
      obj.matchText = message.matchText;
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.startLine !== 0) {
      obj.startLine = Math.round(message.startLine);
    }
    if (message.endLine !== 0) {
      obj.endLine = Math.round(message.endLine);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResult>, I>>(base?: I): SearchResult {
    return SearchResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResult>, I>>(object: I): SearchResult {
    const message = createBaseSearchResult();
    message.filePath = object.filePath ?? "";
    message.lineNumber = object.lineNumber ?? 0;
    message.matchText = object.matchText ?? "";
    message.context = object.context ?? "";
    message.startLine = object.startLine ?? 0;
    message.endLine = object.endLine ?? 0;
    return message;
  },
};

function createBaseCodeDefinitionRequest(): CodeDefinitionRequest {
  return { path: "", filePattern: "" };
}

export const CodeDefinitionRequest: MessageFns<CodeDefinitionRequest> = {
  encode(message: CodeDefinitionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.filePattern !== "") {
      writer.uint32(18).string(message.filePattern);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CodeDefinitionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodeDefinitionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filePattern = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CodeDefinitionRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      filePattern: isSet(object.filePattern) ? globalThis.String(object.filePattern) : "",
    };
  },

  toJSON(message: CodeDefinitionRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.filePattern !== "") {
      obj.filePattern = message.filePattern;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CodeDefinitionRequest>, I>>(base?: I): CodeDefinitionRequest {
    return CodeDefinitionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CodeDefinitionRequest>, I>>(object: I): CodeDefinitionRequest {
    const message = createBaseCodeDefinitionRequest();
    message.path = object.path ?? "";
    message.filePattern = object.filePattern ?? "";
    return message;
  },
};

function createBaseCodeDefinitionResponse(): CodeDefinitionResponse {
  return { definitions: [], error: "" };
}

export const CodeDefinitionResponse: MessageFns<CodeDefinitionResponse> = {
  encode(message: CodeDefinitionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.definitions) {
      CodeDefinition.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CodeDefinitionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodeDefinitionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.definitions.push(CodeDefinition.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CodeDefinitionResponse {
    return {
      definitions: globalThis.Array.isArray(object?.definitions)
        ? object.definitions.map((e: any) => CodeDefinition.fromJSON(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: CodeDefinitionResponse): unknown {
    const obj: any = {};
    if (message.definitions?.length) {
      obj.definitions = message.definitions.map((e) => CodeDefinition.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CodeDefinitionResponse>, I>>(base?: I): CodeDefinitionResponse {
    return CodeDefinitionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CodeDefinitionResponse>, I>>(object: I): CodeDefinitionResponse {
    const message = createBaseCodeDefinitionResponse();
    message.definitions = object.definitions?.map((e) => CodeDefinition.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseCodeDefinition(): CodeDefinition {
  return { filePath: "", name: "", type: "", lineNumber: 0, signature: "" };
}

export const CodeDefinition: MessageFns<CodeDefinition> = {
  encode(message: CodeDefinition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filePath !== "") {
      writer.uint32(10).string(message.filePath);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    if (message.lineNumber !== 0) {
      writer.uint32(32).int32(message.lineNumber);
    }
    if (message.signature !== "") {
      writer.uint32(42).string(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CodeDefinition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCodeDefinition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filePath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lineNumber = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CodeDefinition {
    return {
      filePath: isSet(object.filePath) ? globalThis.String(object.filePath) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      lineNumber: isSet(object.lineNumber) ? globalThis.Number(object.lineNumber) : 0,
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
    };
  },

  toJSON(message: CodeDefinition): unknown {
    const obj: any = {};
    if (message.filePath !== "") {
      obj.filePath = message.filePath;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.lineNumber !== 0) {
      obj.lineNumber = Math.round(message.lineNumber);
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CodeDefinition>, I>>(base?: I): CodeDefinition {
    return CodeDefinition.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CodeDefinition>, I>>(object: I): CodeDefinition {
    const message = createBaseCodeDefinition();
    message.filePath = object.filePath ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? "";
    message.lineNumber = object.lineNumber ?? 0;
    message.signature = object.signature ?? "";
    return message;
  },
};

function createBaseReplaceInFileRequest(): ReplaceInFileRequest {
  return { path: "", replacements: [] };
}

export const ReplaceInFileRequest: MessageFns<ReplaceInFileRequest> = {
  encode(message: ReplaceInFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    for (const v of message.replacements) {
      Replacement.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplaceInFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplaceInFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.replacements.push(Replacement.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplaceInFileRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      replacements: globalThis.Array.isArray(object?.replacements)
        ? object.replacements.map((e: any) => Replacement.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ReplaceInFileRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.replacements?.length) {
      obj.replacements = message.replacements.map((e) => Replacement.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReplaceInFileRequest>, I>>(base?: I): ReplaceInFileRequest {
    return ReplaceInFileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReplaceInFileRequest>, I>>(object: I): ReplaceInFileRequest {
    const message = createBaseReplaceInFileRequest();
    message.path = object.path ?? "";
    message.replacements = object.replacements?.map((e) => Replacement.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReplacement(): Replacement {
  return { search: "", replace: "" };
}

export const Replacement: MessageFns<Replacement> = {
  encode(message: Replacement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.search !== "") {
      writer.uint32(10).string(message.search);
    }
    if (message.replace !== "") {
      writer.uint32(18).string(message.replace);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Replacement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplacement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.search = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.replace = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Replacement {
    return {
      search: isSet(object.search) ? globalThis.String(object.search) : "",
      replace: isSet(object.replace) ? globalThis.String(object.replace) : "",
    };
  },

  toJSON(message: Replacement): unknown {
    const obj: any = {};
    if (message.search !== "") {
      obj.search = message.search;
    }
    if (message.replace !== "") {
      obj.replace = message.replace;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Replacement>, I>>(base?: I): Replacement {
    return Replacement.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Replacement>, I>>(object: I): Replacement {
    const message = createBaseReplacement();
    message.search = object.search ?? "";
    message.replace = object.replace ?? "";
    return message;
  },
};

function createBaseReplaceInFileResponse(): ReplaceInFileResponse {
  return { success: false, error: "", replacementsMade: 0 };
}

export const ReplaceInFileResponse: MessageFns<ReplaceInFileResponse> = {
  encode(message: ReplaceInFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    if (message.replacementsMade !== 0) {
      writer.uint32(24).int32(message.replacementsMade);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplaceInFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplaceInFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.replacementsMade = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReplaceInFileResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      replacementsMade: isSet(object.replacementsMade) ? globalThis.Number(object.replacementsMade) : 0,
    };
  },

  toJSON(message: ReplaceInFileResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.replacementsMade !== 0) {
      obj.replacementsMade = Math.round(message.replacementsMade);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReplaceInFileResponse>, I>>(base?: I): ReplaceInFileResponse {
    return ReplaceInFileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReplaceInFileResponse>, I>>(object: I): ReplaceInFileResponse {
    const message = createBaseReplaceInFileResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    message.replacementsMade = object.replacementsMade ?? 0;
    return message;
  },
};

/** Search service for finding patterns in files */
export type SearchServiceService = typeof SearchServiceService;
export const SearchServiceService = {
  /** Search for a pattern in files */
  searchFiles: {
    path: "/cline.SearchService/SearchFiles",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SearchFilesRequest) => Buffer.from(SearchFilesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SearchFilesRequest.decode(value),
    responseSerialize: (value: SearchFilesResponse) => Buffer.from(SearchFilesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SearchFilesResponse.decode(value),
  },
  /** Get code definition names from files */
  listCodeDefinitionNames: {
    path: "/cline.SearchService/ListCodeDefinitionNames",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CodeDefinitionRequest) => Buffer.from(CodeDefinitionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CodeDefinitionRequest.decode(value),
    responseSerialize: (value: CodeDefinitionResponse) => Buffer.from(CodeDefinitionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CodeDefinitionResponse.decode(value),
  },
  /** Replace text in files */
  replaceInFile: {
    path: "/cline.SearchService/ReplaceInFile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReplaceInFileRequest) => Buffer.from(ReplaceInFileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ReplaceInFileRequest.decode(value),
    responseSerialize: (value: ReplaceInFileResponse) => Buffer.from(ReplaceInFileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ReplaceInFileResponse.decode(value),
  },
} as const;

export interface SearchServiceServer extends UntypedServiceImplementation {
  /** Search for a pattern in files */
  searchFiles: handleUnaryCall<SearchFilesRequest, SearchFilesResponse>;
  /** Get code definition names from files */
  listCodeDefinitionNames: handleUnaryCall<CodeDefinitionRequest, CodeDefinitionResponse>;
  /** Replace text in files */
  replaceInFile: handleUnaryCall<ReplaceInFileRequest, ReplaceInFileResponse>;
}

export interface SearchServiceClient extends Client {
  /** Search for a pattern in files */
  searchFiles(
    request: SearchFilesRequest,
    callback: (error: ServiceError | null, response: SearchFilesResponse) => void,
  ): ClientUnaryCall;
  searchFiles(
    request: SearchFilesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: SearchFilesResponse) => void,
  ): ClientUnaryCall;
  searchFiles(
    request: SearchFilesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: SearchFilesResponse) => void,
  ): ClientUnaryCall;
  /** Get code definition names from files */
  listCodeDefinitionNames(
    request: CodeDefinitionRequest,
    callback: (error: ServiceError | null, response: CodeDefinitionResponse) => void,
  ): ClientUnaryCall;
  listCodeDefinitionNames(
    request: CodeDefinitionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CodeDefinitionResponse) => void,
  ): ClientUnaryCall;
  listCodeDefinitionNames(
    request: CodeDefinitionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CodeDefinitionResponse) => void,
  ): ClientUnaryCall;
  /** Replace text in files */
  replaceInFile(
    request: ReplaceInFileRequest,
    callback: (error: ServiceError | null, response: ReplaceInFileResponse) => void,
  ): ClientUnaryCall;
  replaceInFile(
    request: ReplaceInFileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ReplaceInFileResponse) => void,
  ): ClientUnaryCall;
  replaceInFile(
    request: ReplaceInFileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ReplaceInFileResponse) => void,
  ): ClientUnaryCall;
}

export const SearchServiceClient = makeGenericClientConstructor(
  SearchServiceService,
  "cline.SearchService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): SearchServiceClient;
  service: typeof SearchServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
