// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.0
// source: ai_provider.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "cline";

/** Request to list providers */
export interface ListProvidersRequest {
  /** Only include providers that have been configured */
  includeConfiguredOnly: boolean;
}

/** Response with list of providers */
export interface ListProvidersResponse {
  /** Available AI providers */
  providers: AIProvider[];
  /** Error message if any */
  error: string;
}

/** AI provider information */
export interface AIProvider {
  /** Provider ID (e.g., "openai", "anthropic") */
  id: string;
  /** Display name */
  name: string;
  /** Whether the provider is configured */
  isConfigured: boolean;
  /** Available models for this provider */
  availableModels: string[];
  /** Maximum context window size (in tokens) */
  maxContextWindow: number;
  /** Provider capabilities */
  capabilities: ProviderCapabilities | undefined;
}

/** Provider capabilities */
export interface ProviderCapabilities {
  /** Whether the provider supports streaming */
  supportsStreaming: boolean;
  /** Whether the provider supports vision models */
  supportsVision: boolean;
  /** Whether the provider supports JSON mode */
  supportsJsonMode: boolean;
  /** Whether the provider supports function calling */
  supportsFunctionCalling: boolean;
}

/** Request to get provider models */
export interface GetProviderModelsRequest {
  /** Provider ID */
  providerId: string;
}

/** Response with provider models */
export interface GetProviderModelsResponse {
  /** Available models */
  models: Model[];
  /** Error message if any */
  error: string;
}

/** Model information */
export interface Model {
  /** Model ID */
  id: string;
  /** Display name */
  displayName: string;
  /** Maximum token count */
  maxTokens: number;
  /** Whether the model supports vision */
  supportsVision: boolean;
  /** Maximum context window size (in tokens) */
  maxContextWindow: number;
  /** Tokens processed per minute (approximate) */
  tokensPerMinute: number;
  /** Cost per 1000 input tokens */
  costPer1kTokensInput: number;
  /** Cost per 1000 output tokens */
  costPer1kTokensOutput: number;
}

/** Request to complete a prompt */
export interface CompletePromptRequest {
  /** Provider ID */
  providerId: string;
  /** Model ID */
  modelId: string;
  /** Conversation messages */
  messages: Message[];
  /** Temperature (0.0-2.0) */
  temperature: number;
  /** Maximum tokens to generate */
  maxTokens: number;
  /** Sequences that stop generation */
  stopSequences: string[];
  /** Provider-specific options */
  options: ProviderOptions | undefined;
}

/** Message in a conversation */
export interface Message {
  /** Role (system, user, assistant, tool) */
  role: string;
  /** Text content */
  content: string;
  /** Attachments (images, etc.) */
  attachments: AttachmentContent[];
  /** Name (for tool messages) */
  name: string;
  /** Tool call information */
  toolCall:
    | ToolCall
    | undefined;
  /** Tool result information */
  toolResult: ToolResult | undefined;
}

/** Attachment content (for images, etc.) */
export interface AttachmentContent {
  /** Type of attachment (image, audio, etc.) */
  type: string;
  /** Binary data */
  data: Buffer;
  /** URL (alternative to data) */
  url: string;
  /** MIME type */
  mimeType: string;
}

/** Tool call information */
export interface ToolCall {
  /** Tool call ID */
  id: string;
  /** Tool name */
  name: string;
  /** Tool arguments (JSON) */
  arguments: string;
}

/** Tool result information */
export interface ToolResult {
  /** Tool call ID */
  id: string;
  /** Tool result */
  result: string;
}

/** Provider-specific options */
export interface ProviderOptions {
  /** Whether to use JSON mode */
  jsonMode: boolean;
  /** Available tools */
  tools: Tool[];
  /** Extra provider-specific options */
  extraOptions: { [key: string]: string };
}

export interface ProviderOptions_ExtraOptionsEntry {
  key: string;
  value: string;
}

/** Tool definition */
export interface Tool {
  /** Tool name */
  name: string;
  /** Tool description */
  description: string;
  /** Tool schema (JSON Schema) */
  schema: string;
}

/** Response from completing a prompt */
export interface CompletePromptResponse {
  /** Completion text */
  completion: string;
  /** Number of tokens in the prompt */
  promptTokens: number;
  /** Number of tokens in the completion */
  completionTokens: number;
  /** Error message if any */
  error: string;
  /** Cost of the completion */
  cost: number;
}

/** Chunk for streaming completion */
export interface CompletionChunk {
  /** Text delta */
  delta: string;
  /** Whether this is the final chunk */
  isFinal: boolean;
  /** Error message if any */
  error: string;
  /** Number of tokens in the prompt (only in final chunk) */
  promptTokens: number;
  /** Number of tokens in the completion (only in final chunk) */
  completionTokens: number;
  /** Cost of the completion (only in final chunk) */
  cost: number;
}

/** Request to configure a provider */
export interface ConfigureProviderRequest {
  /** Provider ID */
  providerId: string;
  /** Provider credentials */
  credentials: { [key: string]: string };
  /** Provider settings */
  settings: { [key: string]: string };
}

export interface ConfigureProviderRequest_CredentialsEntry {
  key: string;
  value: string;
}

export interface ConfigureProviderRequest_SettingsEntry {
  key: string;
  value: string;
}

/** Response from configuring a provider */
export interface ConfigureProviderResponse {
  /** Whether the configuration was successful */
  success: boolean;
  /** Error message if any */
  error: string;
}

function createBaseListProvidersRequest(): ListProvidersRequest {
  return { includeConfiguredOnly: false };
}

export const ListProvidersRequest: MessageFns<ListProvidersRequest> = {
  encode(message: ListProvidersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.includeConfiguredOnly !== false) {
      writer.uint32(8).bool(message.includeConfiguredOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProvidersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProvidersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.includeConfiguredOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProvidersRequest {
    return {
      includeConfiguredOnly: isSet(object.includeConfiguredOnly)
        ? globalThis.Boolean(object.includeConfiguredOnly)
        : false,
    };
  },

  toJSON(message: ListProvidersRequest): unknown {
    const obj: any = {};
    if (message.includeConfiguredOnly !== false) {
      obj.includeConfiguredOnly = message.includeConfiguredOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProvidersRequest>, I>>(base?: I): ListProvidersRequest {
    return ListProvidersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProvidersRequest>, I>>(object: I): ListProvidersRequest {
    const message = createBaseListProvidersRequest();
    message.includeConfiguredOnly = object.includeConfiguredOnly ?? false;
    return message;
  },
};

function createBaseListProvidersResponse(): ListProvidersResponse {
  return { providers: [], error: "" };
}

export const ListProvidersResponse: MessageFns<ListProvidersResponse> = {
  encode(message: ListProvidersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.providers) {
      AIProvider.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListProvidersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListProvidersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providers.push(AIProvider.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListProvidersResponse {
    return {
      providers: globalThis.Array.isArray(object?.providers)
        ? object.providers.map((e: any) => AIProvider.fromJSON(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ListProvidersResponse): unknown {
    const obj: any = {};
    if (message.providers?.length) {
      obj.providers = message.providers.map((e) => AIProvider.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListProvidersResponse>, I>>(base?: I): ListProvidersResponse {
    return ListProvidersResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListProvidersResponse>, I>>(object: I): ListProvidersResponse {
    const message = createBaseListProvidersResponse();
    message.providers = object.providers?.map((e) => AIProvider.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseAIProvider(): AIProvider {
  return { id: "", name: "", isConfigured: false, availableModels: [], maxContextWindow: 0, capabilities: undefined };
}

export const AIProvider: MessageFns<AIProvider> = {
  encode(message: AIProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.isConfigured !== false) {
      writer.uint32(24).bool(message.isConfigured);
    }
    for (const v of message.availableModels) {
      writer.uint32(34).string(v!);
    }
    if (message.maxContextWindow !== 0) {
      writer.uint32(40).int32(message.maxContextWindow);
    }
    if (message.capabilities !== undefined) {
      ProviderCapabilities.encode(message.capabilities, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AIProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAIProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isConfigured = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.availableModels.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxContextWindow = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.capabilities = ProviderCapabilities.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AIProvider {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      isConfigured: isSet(object.isConfigured) ? globalThis.Boolean(object.isConfigured) : false,
      availableModels: globalThis.Array.isArray(object?.availableModels)
        ? object.availableModels.map((e: any) => globalThis.String(e))
        : [],
      maxContextWindow: isSet(object.maxContextWindow) ? globalThis.Number(object.maxContextWindow) : 0,
      capabilities: isSet(object.capabilities) ? ProviderCapabilities.fromJSON(object.capabilities) : undefined,
    };
  },

  toJSON(message: AIProvider): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.isConfigured !== false) {
      obj.isConfigured = message.isConfigured;
    }
    if (message.availableModels?.length) {
      obj.availableModels = message.availableModels;
    }
    if (message.maxContextWindow !== 0) {
      obj.maxContextWindow = Math.round(message.maxContextWindow);
    }
    if (message.capabilities !== undefined) {
      obj.capabilities = ProviderCapabilities.toJSON(message.capabilities);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AIProvider>, I>>(base?: I): AIProvider {
    return AIProvider.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AIProvider>, I>>(object: I): AIProvider {
    const message = createBaseAIProvider();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.isConfigured = object.isConfigured ?? false;
    message.availableModels = object.availableModels?.map((e) => e) || [];
    message.maxContextWindow = object.maxContextWindow ?? 0;
    message.capabilities = (object.capabilities !== undefined && object.capabilities !== null)
      ? ProviderCapabilities.fromPartial(object.capabilities)
      : undefined;
    return message;
  },
};

function createBaseProviderCapabilities(): ProviderCapabilities {
  return { supportsStreaming: false, supportsVision: false, supportsJsonMode: false, supportsFunctionCalling: false };
}

export const ProviderCapabilities: MessageFns<ProviderCapabilities> = {
  encode(message: ProviderCapabilities, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.supportsStreaming !== false) {
      writer.uint32(8).bool(message.supportsStreaming);
    }
    if (message.supportsVision !== false) {
      writer.uint32(16).bool(message.supportsVision);
    }
    if (message.supportsJsonMode !== false) {
      writer.uint32(24).bool(message.supportsJsonMode);
    }
    if (message.supportsFunctionCalling !== false) {
      writer.uint32(32).bool(message.supportsFunctionCalling);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderCapabilities {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderCapabilities();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.supportsStreaming = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.supportsVision = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.supportsJsonMode = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.supportsFunctionCalling = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderCapabilities {
    return {
      supportsStreaming: isSet(object.supportsStreaming) ? globalThis.Boolean(object.supportsStreaming) : false,
      supportsVision: isSet(object.supportsVision) ? globalThis.Boolean(object.supportsVision) : false,
      supportsJsonMode: isSet(object.supportsJsonMode) ? globalThis.Boolean(object.supportsJsonMode) : false,
      supportsFunctionCalling: isSet(object.supportsFunctionCalling)
        ? globalThis.Boolean(object.supportsFunctionCalling)
        : false,
    };
  },

  toJSON(message: ProviderCapabilities): unknown {
    const obj: any = {};
    if (message.supportsStreaming !== false) {
      obj.supportsStreaming = message.supportsStreaming;
    }
    if (message.supportsVision !== false) {
      obj.supportsVision = message.supportsVision;
    }
    if (message.supportsJsonMode !== false) {
      obj.supportsJsonMode = message.supportsJsonMode;
    }
    if (message.supportsFunctionCalling !== false) {
      obj.supportsFunctionCalling = message.supportsFunctionCalling;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProviderCapabilities>, I>>(base?: I): ProviderCapabilities {
    return ProviderCapabilities.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProviderCapabilities>, I>>(object: I): ProviderCapabilities {
    const message = createBaseProviderCapabilities();
    message.supportsStreaming = object.supportsStreaming ?? false;
    message.supportsVision = object.supportsVision ?? false;
    message.supportsJsonMode = object.supportsJsonMode ?? false;
    message.supportsFunctionCalling = object.supportsFunctionCalling ?? false;
    return message;
  },
};

function createBaseGetProviderModelsRequest(): GetProviderModelsRequest {
  return { providerId: "" };
}

export const GetProviderModelsRequest: MessageFns<GetProviderModelsRequest> = {
  encode(message: GetProviderModelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerId !== "") {
      writer.uint32(10).string(message.providerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProviderModelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProviderModelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProviderModelsRequest {
    return { providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "" };
  },

  toJSON(message: GetProviderModelsRequest): unknown {
    const obj: any = {};
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProviderModelsRequest>, I>>(base?: I): GetProviderModelsRequest {
    return GetProviderModelsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProviderModelsRequest>, I>>(object: I): GetProviderModelsRequest {
    const message = createBaseGetProviderModelsRequest();
    message.providerId = object.providerId ?? "";
    return message;
  },
};

function createBaseGetProviderModelsResponse(): GetProviderModelsResponse {
  return { models: [], error: "" };
}

export const GetProviderModelsResponse: MessageFns<GetProviderModelsResponse> = {
  encode(message: GetProviderModelsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.models) {
      Model.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetProviderModelsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProviderModelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.models.push(Model.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetProviderModelsResponse {
    return {
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => Model.fromJSON(e)) : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: GetProviderModelsResponse): unknown {
    const obj: any = {};
    if (message.models?.length) {
      obj.models = message.models.map((e) => Model.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetProviderModelsResponse>, I>>(base?: I): GetProviderModelsResponse {
    return GetProviderModelsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetProviderModelsResponse>, I>>(object: I): GetProviderModelsResponse {
    const message = createBaseGetProviderModelsResponse();
    message.models = object.models?.map((e) => Model.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseModel(): Model {
  return {
    id: "",
    displayName: "",
    maxTokens: 0,
    supportsVision: false,
    maxContextWindow: 0,
    tokensPerMinute: 0,
    costPer1kTokensInput: 0,
    costPer1kTokensOutput: 0,
  };
}

export const Model: MessageFns<Model> = {
  encode(message: Model, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.maxTokens !== 0) {
      writer.uint32(24).int32(message.maxTokens);
    }
    if (message.supportsVision !== false) {
      writer.uint32(32).bool(message.supportsVision);
    }
    if (message.maxContextWindow !== 0) {
      writer.uint32(40).int32(message.maxContextWindow);
    }
    if (message.tokensPerMinute !== 0) {
      writer.uint32(53).float(message.tokensPerMinute);
    }
    if (message.costPer1kTokensInput !== 0) {
      writer.uint32(61).float(message.costPer1kTokensInput);
    }
    if (message.costPer1kTokensOutput !== 0) {
      writer.uint32(69).float(message.costPer1kTokensOutput);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Model {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.supportsVision = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxContextWindow = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.tokensPerMinute = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.costPer1kTokensInput = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 69) {
            break;
          }

          message.costPer1kTokensOutput = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Model {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : 0,
      supportsVision: isSet(object.supportsVision) ? globalThis.Boolean(object.supportsVision) : false,
      maxContextWindow: isSet(object.maxContextWindow) ? globalThis.Number(object.maxContextWindow) : 0,
      tokensPerMinute: isSet(object.tokensPerMinute) ? globalThis.Number(object.tokensPerMinute) : 0,
      costPer1kTokensInput: isSet(object.costPer1kTokensInput) ? globalThis.Number(object.costPer1kTokensInput) : 0,
      costPer1kTokensOutput: isSet(object.costPer1kTokensOutput) ? globalThis.Number(object.costPer1kTokensOutput) : 0,
    };
  },

  toJSON(message: Model): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.supportsVision !== false) {
      obj.supportsVision = message.supportsVision;
    }
    if (message.maxContextWindow !== 0) {
      obj.maxContextWindow = Math.round(message.maxContextWindow);
    }
    if (message.tokensPerMinute !== 0) {
      obj.tokensPerMinute = message.tokensPerMinute;
    }
    if (message.costPer1kTokensInput !== 0) {
      obj.costPer1kTokensInput = message.costPer1kTokensInput;
    }
    if (message.costPer1kTokensOutput !== 0) {
      obj.costPer1kTokensOutput = message.costPer1kTokensOutput;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Model>, I>>(base?: I): Model {
    return Model.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Model>, I>>(object: I): Model {
    const message = createBaseModel();
    message.id = object.id ?? "";
    message.displayName = object.displayName ?? "";
    message.maxTokens = object.maxTokens ?? 0;
    message.supportsVision = object.supportsVision ?? false;
    message.maxContextWindow = object.maxContextWindow ?? 0;
    message.tokensPerMinute = object.tokensPerMinute ?? 0;
    message.costPer1kTokensInput = object.costPer1kTokensInput ?? 0;
    message.costPer1kTokensOutput = object.costPer1kTokensOutput ?? 0;
    return message;
  },
};

function createBaseCompletePromptRequest(): CompletePromptRequest {
  return {
    providerId: "",
    modelId: "",
    messages: [],
    temperature: 0,
    maxTokens: 0,
    stopSequences: [],
    options: undefined,
  };
}

export const CompletePromptRequest: MessageFns<CompletePromptRequest> = {
  encode(message: CompletePromptRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerId !== "") {
      writer.uint32(10).string(message.providerId);
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    for (const v of message.messages) {
      Message.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.temperature !== 0) {
      writer.uint32(37).float(message.temperature);
    }
    if (message.maxTokens !== 0) {
      writer.uint32(40).int32(message.maxTokens);
    }
    for (const v of message.stopSequences) {
      writer.uint32(50).string(v!);
    }
    if (message.options !== undefined) {
      ProviderOptions.encode(message.options, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompletePromptRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletePromptRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.messages.push(Message.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 37) {
            break;
          }

          message.temperature = reader.float();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxTokens = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.stopSequences.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.options = ProviderOptions.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletePromptRequest {
    return {
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
      modelId: isSet(object.modelId) ? globalThis.String(object.modelId) : "",
      messages: globalThis.Array.isArray(object?.messages) ? object.messages.map((e: any) => Message.fromJSON(e)) : [],
      temperature: isSet(object.temperature) ? globalThis.Number(object.temperature) : 0,
      maxTokens: isSet(object.maxTokens) ? globalThis.Number(object.maxTokens) : 0,
      stopSequences: globalThis.Array.isArray(object?.stopSequences)
        ? object.stopSequences.map((e: any) => globalThis.String(e))
        : [],
      options: isSet(object.options) ? ProviderOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: CompletePromptRequest): unknown {
    const obj: any = {};
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    if (message.modelId !== "") {
      obj.modelId = message.modelId;
    }
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => Message.toJSON(e));
    }
    if (message.temperature !== 0) {
      obj.temperature = message.temperature;
    }
    if (message.maxTokens !== 0) {
      obj.maxTokens = Math.round(message.maxTokens);
    }
    if (message.stopSequences?.length) {
      obj.stopSequences = message.stopSequences;
    }
    if (message.options !== undefined) {
      obj.options = ProviderOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompletePromptRequest>, I>>(base?: I): CompletePromptRequest {
    return CompletePromptRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompletePromptRequest>, I>>(object: I): CompletePromptRequest {
    const message = createBaseCompletePromptRequest();
    message.providerId = object.providerId ?? "";
    message.modelId = object.modelId ?? "";
    message.messages = object.messages?.map((e) => Message.fromPartial(e)) || [];
    message.temperature = object.temperature ?? 0;
    message.maxTokens = object.maxTokens ?? 0;
    message.stopSequences = object.stopSequences?.map((e) => e) || [];
    message.options = (object.options !== undefined && object.options !== null)
      ? ProviderOptions.fromPartial(object.options)
      : undefined;
    return message;
  },
};

function createBaseMessage(): Message {
  return { role: "", content: "", attachments: [], name: "", toolCall: undefined, toolResult: undefined };
}

export const Message: MessageFns<Message> = {
  encode(message: Message, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.role !== "") {
      writer.uint32(10).string(message.role);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    for (const v of message.attachments) {
      AttachmentContent.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.toolCall !== undefined) {
      ToolCall.encode(message.toolCall, writer.uint32(42).fork()).join();
    }
    if (message.toolResult !== undefined) {
      ToolResult.encode(message.toolResult, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.attachments.push(AttachmentContent.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.toolCall = ToolCall.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.toolResult = ToolResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      attachments: globalThis.Array.isArray(object?.attachments)
        ? object.attachments.map((e: any) => AttachmentContent.fromJSON(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      toolCall: isSet(object.toolCall) ? ToolCall.fromJSON(object.toolCall) : undefined,
      toolResult: isSet(object.toolResult) ? ToolResult.fromJSON(object.toolResult) : undefined,
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.attachments?.length) {
      obj.attachments = message.attachments.map((e) => AttachmentContent.toJSON(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.toolCall !== undefined) {
      obj.toolCall = ToolCall.toJSON(message.toolCall);
    }
    if (message.toolResult !== undefined) {
      obj.toolResult = ToolResult.toJSON(message.toolResult);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.role = object.role ?? "";
    message.content = object.content ?? "";
    message.attachments = object.attachments?.map((e) => AttachmentContent.fromPartial(e)) || [];
    message.name = object.name ?? "";
    message.toolCall = (object.toolCall !== undefined && object.toolCall !== null)
      ? ToolCall.fromPartial(object.toolCall)
      : undefined;
    message.toolResult = (object.toolResult !== undefined && object.toolResult !== null)
      ? ToolResult.fromPartial(object.toolResult)
      : undefined;
    return message;
  },
};

function createBaseAttachmentContent(): AttachmentContent {
  return { type: "", data: Buffer.alloc(0), url: "", mimeType: "" };
}

export const AttachmentContent: MessageFns<AttachmentContent> = {
  encode(message: AttachmentContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.url !== "") {
      writer.uint32(26).string(message.url);
    }
    if (message.mimeType !== "") {
      writer.uint32(34).string(message.mimeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttachmentContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttachmentContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttachmentContent {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      data: isSet(object.data) ? Buffer.from(bytesFromBase64(object.data)) : Buffer.alloc(0),
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
    };
  },

  toJSON(message: AttachmentContent): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AttachmentContent>, I>>(base?: I): AttachmentContent {
    return AttachmentContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AttachmentContent>, I>>(object: I): AttachmentContent {
    const message = createBaseAttachmentContent();
    message.type = object.type ?? "";
    message.data = object.data ?? Buffer.alloc(0);
    message.url = object.url ?? "";
    message.mimeType = object.mimeType ?? "";
    return message;
  },
};

function createBaseToolCall(): ToolCall {
  return { id: "", name: "", arguments: "" };
}

export const ToolCall: MessageFns<ToolCall> = {
  encode(message: ToolCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.arguments !== "") {
      writer.uint32(26).string(message.arguments);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.arguments = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolCall {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      arguments: isSet(object.arguments) ? globalThis.String(object.arguments) : "",
    };
  },

  toJSON(message: ToolCall): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.arguments !== "") {
      obj.arguments = message.arguments;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolCall>, I>>(base?: I): ToolCall {
    return ToolCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolCall>, I>>(object: I): ToolCall {
    const message = createBaseToolCall();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.arguments = object.arguments ?? "";
    return message;
  },
};

function createBaseToolResult(): ToolResult {
  return { id: "", result: "" };
}

export const ToolResult: MessageFns<ToolResult> = {
  encode(message: ToolResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.result !== "") {
      writer.uint32(18).string(message.result);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToolResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToolResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.result = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToolResult {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      result: isSet(object.result) ? globalThis.String(object.result) : "",
    };
  },

  toJSON(message: ToolResult): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.result !== "") {
      obj.result = message.result;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToolResult>, I>>(base?: I): ToolResult {
    return ToolResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToolResult>, I>>(object: I): ToolResult {
    const message = createBaseToolResult();
    message.id = object.id ?? "";
    message.result = object.result ?? "";
    return message;
  },
};

function createBaseProviderOptions(): ProviderOptions {
  return { jsonMode: false, tools: [], extraOptions: {} };
}

export const ProviderOptions: MessageFns<ProviderOptions> = {
  encode(message: ProviderOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jsonMode !== false) {
      writer.uint32(8).bool(message.jsonMode);
    }
    for (const v of message.tools) {
      Tool.encode(v!, writer.uint32(18).fork()).join();
    }
    Object.entries(message.extraOptions).forEach(([key, value]) => {
      ProviderOptions_ExtraOptionsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.jsonMode = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tools.push(Tool.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ProviderOptions_ExtraOptionsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.extraOptions[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderOptions {
    return {
      jsonMode: isSet(object.jsonMode) ? globalThis.Boolean(object.jsonMode) : false,
      tools: globalThis.Array.isArray(object?.tools) ? object.tools.map((e: any) => Tool.fromJSON(e)) : [],
      extraOptions: isObject(object.extraOptions)
        ? Object.entries(object.extraOptions).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ProviderOptions): unknown {
    const obj: any = {};
    if (message.jsonMode !== false) {
      obj.jsonMode = message.jsonMode;
    }
    if (message.tools?.length) {
      obj.tools = message.tools.map((e) => Tool.toJSON(e));
    }
    if (message.extraOptions) {
      const entries = Object.entries(message.extraOptions);
      if (entries.length > 0) {
        obj.extraOptions = {};
        entries.forEach(([k, v]) => {
          obj.extraOptions[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProviderOptions>, I>>(base?: I): ProviderOptions {
    return ProviderOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProviderOptions>, I>>(object: I): ProviderOptions {
    const message = createBaseProviderOptions();
    message.jsonMode = object.jsonMode ?? false;
    message.tools = object.tools?.map((e) => Tool.fromPartial(e)) || [];
    message.extraOptions = Object.entries(object.extraOptions ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseProviderOptions_ExtraOptionsEntry(): ProviderOptions_ExtraOptionsEntry {
  return { key: "", value: "" };
}

export const ProviderOptions_ExtraOptionsEntry: MessageFns<ProviderOptions_ExtraOptionsEntry> = {
  encode(message: ProviderOptions_ExtraOptionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProviderOptions_ExtraOptionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProviderOptions_ExtraOptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProviderOptions_ExtraOptionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ProviderOptions_ExtraOptionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProviderOptions_ExtraOptionsEntry>, I>>(
    base?: I,
  ): ProviderOptions_ExtraOptionsEntry {
    return ProviderOptions_ExtraOptionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProviderOptions_ExtraOptionsEntry>, I>>(
    object: I,
  ): ProviderOptions_ExtraOptionsEntry {
    const message = createBaseProviderOptions_ExtraOptionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseTool(): Tool {
  return { name: "", description: "", schema: "" };
}

export const Tool: MessageFns<Tool> = {
  encode(message: Tool, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.schema !== "") {
      writer.uint32(26).string(message.schema);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Tool {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTool();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.schema = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Tool {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      schema: isSet(object.schema) ? globalThis.String(object.schema) : "",
    };
  },

  toJSON(message: Tool): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.schema !== "") {
      obj.schema = message.schema;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Tool>, I>>(base?: I): Tool {
    return Tool.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Tool>, I>>(object: I): Tool {
    const message = createBaseTool();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.schema = object.schema ?? "";
    return message;
  },
};

function createBaseCompletePromptResponse(): CompletePromptResponse {
  return { completion: "", promptTokens: 0, completionTokens: 0, error: "", cost: 0 };
}

export const CompletePromptResponse: MessageFns<CompletePromptResponse> = {
  encode(message: CompletePromptResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.completion !== "") {
      writer.uint32(10).string(message.completion);
    }
    if (message.promptTokens !== 0) {
      writer.uint32(16).int32(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      writer.uint32(24).int32(message.completionTokens);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    if (message.cost !== 0) {
      writer.uint32(45).float(message.cost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompletePromptResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletePromptResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.completion = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.promptTokens = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.completionTokens = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 45) {
            break;
          }

          message.cost = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletePromptResponse {
    return {
      completion: isSet(object.completion) ? globalThis.String(object.completion) : "",
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : 0,
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      cost: isSet(object.cost) ? globalThis.Number(object.cost) : 0,
    };
  },

  toJSON(message: CompletePromptResponse): unknown {
    const obj: any = {};
    if (message.completion !== "") {
      obj.completion = message.completion;
    }
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.cost !== 0) {
      obj.cost = message.cost;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompletePromptResponse>, I>>(base?: I): CompletePromptResponse {
    return CompletePromptResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompletePromptResponse>, I>>(object: I): CompletePromptResponse {
    const message = createBaseCompletePromptResponse();
    message.completion = object.completion ?? "";
    message.promptTokens = object.promptTokens ?? 0;
    message.completionTokens = object.completionTokens ?? 0;
    message.error = object.error ?? "";
    message.cost = object.cost ?? 0;
    return message;
  },
};

function createBaseCompletionChunk(): CompletionChunk {
  return { delta: "", isFinal: false, error: "", promptTokens: 0, completionTokens: 0, cost: 0 };
}

export const CompletionChunk: MessageFns<CompletionChunk> = {
  encode(message: CompletionChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delta !== "") {
      writer.uint32(10).string(message.delta);
    }
    if (message.isFinal !== false) {
      writer.uint32(16).bool(message.isFinal);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    if (message.promptTokens !== 0) {
      writer.uint32(32).int32(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      writer.uint32(40).int32(message.completionTokens);
    }
    if (message.cost !== 0) {
      writer.uint32(53).float(message.cost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompletionChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompletionChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delta = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isFinal = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.promptTokens = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.completionTokens = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.cost = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompletionChunk {
    return {
      delta: isSet(object.delta) ? globalThis.String(object.delta) : "",
      isFinal: isSet(object.isFinal) ? globalThis.Boolean(object.isFinal) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : 0,
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : 0,
      cost: isSet(object.cost) ? globalThis.Number(object.cost) : 0,
    };
  },

  toJSON(message: CompletionChunk): unknown {
    const obj: any = {};
    if (message.delta !== "") {
      obj.delta = message.delta;
    }
    if (message.isFinal !== false) {
      obj.isFinal = message.isFinal;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.cost !== 0) {
      obj.cost = message.cost;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompletionChunk>, I>>(base?: I): CompletionChunk {
    return CompletionChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompletionChunk>, I>>(object: I): CompletionChunk {
    const message = createBaseCompletionChunk();
    message.delta = object.delta ?? "";
    message.isFinal = object.isFinal ?? false;
    message.error = object.error ?? "";
    message.promptTokens = object.promptTokens ?? 0;
    message.completionTokens = object.completionTokens ?? 0;
    message.cost = object.cost ?? 0;
    return message;
  },
};

function createBaseConfigureProviderRequest(): ConfigureProviderRequest {
  return { providerId: "", credentials: {}, settings: {} };
}

export const ConfigureProviderRequest: MessageFns<ConfigureProviderRequest> = {
  encode(message: ConfigureProviderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerId !== "") {
      writer.uint32(10).string(message.providerId);
    }
    Object.entries(message.credentials).forEach(([key, value]) => {
      ConfigureProviderRequest_CredentialsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    Object.entries(message.settings).forEach(([key, value]) => {
      ConfigureProviderRequest_SettingsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigureProviderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigureProviderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ConfigureProviderRequest_CredentialsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.credentials[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ConfigureProviderRequest_SettingsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.settings[entry3.key] = entry3.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigureProviderRequest {
    return {
      providerId: isSet(object.providerId) ? globalThis.String(object.providerId) : "",
      credentials: isObject(object.credentials)
        ? Object.entries(object.credentials).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      settings: isObject(object.settings)
        ? Object.entries(object.settings).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ConfigureProviderRequest): unknown {
    const obj: any = {};
    if (message.providerId !== "") {
      obj.providerId = message.providerId;
    }
    if (message.credentials) {
      const entries = Object.entries(message.credentials);
      if (entries.length > 0) {
        obj.credentials = {};
        entries.forEach(([k, v]) => {
          obj.credentials[k] = v;
        });
      }
    }
    if (message.settings) {
      const entries = Object.entries(message.settings);
      if (entries.length > 0) {
        obj.settings = {};
        entries.forEach(([k, v]) => {
          obj.settings[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigureProviderRequest>, I>>(base?: I): ConfigureProviderRequest {
    return ConfigureProviderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigureProviderRequest>, I>>(object: I): ConfigureProviderRequest {
    const message = createBaseConfigureProviderRequest();
    message.providerId = object.providerId ?? "";
    message.credentials = Object.entries(object.credentials ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.settings = Object.entries(object.settings ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseConfigureProviderRequest_CredentialsEntry(): ConfigureProviderRequest_CredentialsEntry {
  return { key: "", value: "" };
}

export const ConfigureProviderRequest_CredentialsEntry: MessageFns<ConfigureProviderRequest_CredentialsEntry> = {
  encode(message: ConfigureProviderRequest_CredentialsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigureProviderRequest_CredentialsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigureProviderRequest_CredentialsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigureProviderRequest_CredentialsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConfigureProviderRequest_CredentialsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigureProviderRequest_CredentialsEntry>, I>>(
    base?: I,
  ): ConfigureProviderRequest_CredentialsEntry {
    return ConfigureProviderRequest_CredentialsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigureProviderRequest_CredentialsEntry>, I>>(
    object: I,
  ): ConfigureProviderRequest_CredentialsEntry {
    const message = createBaseConfigureProviderRequest_CredentialsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseConfigureProviderRequest_SettingsEntry(): ConfigureProviderRequest_SettingsEntry {
  return { key: "", value: "" };
}

export const ConfigureProviderRequest_SettingsEntry: MessageFns<ConfigureProviderRequest_SettingsEntry> = {
  encode(message: ConfigureProviderRequest_SettingsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigureProviderRequest_SettingsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigureProviderRequest_SettingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigureProviderRequest_SettingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ConfigureProviderRequest_SettingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigureProviderRequest_SettingsEntry>, I>>(
    base?: I,
  ): ConfigureProviderRequest_SettingsEntry {
    return ConfigureProviderRequest_SettingsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigureProviderRequest_SettingsEntry>, I>>(
    object: I,
  ): ConfigureProviderRequest_SettingsEntry {
    const message = createBaseConfigureProviderRequest_SettingsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseConfigureProviderResponse(): ConfigureProviderResponse {
  return { success: false, error: "" };
}

export const ConfigureProviderResponse: MessageFns<ConfigureProviderResponse> = {
  encode(message: ConfigureProviderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConfigureProviderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConfigureProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConfigureProviderResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ConfigureProviderResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConfigureProviderResponse>, I>>(base?: I): ConfigureProviderResponse {
    return ConfigureProviderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConfigureProviderResponse>, I>>(object: I): ConfigureProviderResponse {
    const message = createBaseConfigureProviderResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

/** AIProvider service for AI model provider interactions */
export type AIProviderServiceService = typeof AIProviderServiceService;
export const AIProviderServiceService = {
  /** List available AI providers */
  listProviders: {
    path: "/cline.AIProviderService/ListProviders",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListProvidersRequest) => Buffer.from(ListProvidersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListProvidersRequest.decode(value),
    responseSerialize: (value: ListProvidersResponse) => Buffer.from(ListProvidersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListProvidersResponse.decode(value),
  },
  /** Get provider models */
  getProviderModels: {
    path: "/cline.AIProviderService/GetProviderModels",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProviderModelsRequest) => Buffer.from(GetProviderModelsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetProviderModelsRequest.decode(value),
    responseSerialize: (value: GetProviderModelsResponse) =>
      Buffer.from(GetProviderModelsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetProviderModelsResponse.decode(value),
  },
  /** Complete a prompt (non-streaming) */
  completePrompt: {
    path: "/cline.AIProviderService/CompletePrompt",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CompletePromptRequest) => Buffer.from(CompletePromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CompletePromptRequest.decode(value),
    responseSerialize: (value: CompletePromptResponse) => Buffer.from(CompletePromptResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CompletePromptResponse.decode(value),
  },
  /** Stream a completion */
  streamCompletion: {
    path: "/cline.AIProviderService/StreamCompletion",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: CompletePromptRequest) => Buffer.from(CompletePromptRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CompletePromptRequest.decode(value),
    responseSerialize: (value: CompletionChunk) => Buffer.from(CompletionChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CompletionChunk.decode(value),
  },
  /** Configure a provider */
  configureProvider: {
    path: "/cline.AIProviderService/ConfigureProvider",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ConfigureProviderRequest) => Buffer.from(ConfigureProviderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ConfigureProviderRequest.decode(value),
    responseSerialize: (value: ConfigureProviderResponse) =>
      Buffer.from(ConfigureProviderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ConfigureProviderResponse.decode(value),
  },
} as const;

export interface AIProviderServiceServer extends UntypedServiceImplementation {
  /** List available AI providers */
  listProviders: handleUnaryCall<ListProvidersRequest, ListProvidersResponse>;
  /** Get provider models */
  getProviderModels: handleUnaryCall<GetProviderModelsRequest, GetProviderModelsResponse>;
  /** Complete a prompt (non-streaming) */
  completePrompt: handleUnaryCall<CompletePromptRequest, CompletePromptResponse>;
  /** Stream a completion */
  streamCompletion: handleServerStreamingCall<CompletePromptRequest, CompletionChunk>;
  /** Configure a provider */
  configureProvider: handleUnaryCall<ConfigureProviderRequest, ConfigureProviderResponse>;
}

export interface AIProviderServiceClient extends Client {
  /** List available AI providers */
  listProviders(
    request: ListProvidersRequest,
    callback: (error: ServiceError | null, response: ListProvidersResponse) => void,
  ): ClientUnaryCall;
  listProviders(
    request: ListProvidersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListProvidersResponse) => void,
  ): ClientUnaryCall;
  listProviders(
    request: ListProvidersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListProvidersResponse) => void,
  ): ClientUnaryCall;
  /** Get provider models */
  getProviderModels(
    request: GetProviderModelsRequest,
    callback: (error: ServiceError | null, response: GetProviderModelsResponse) => void,
  ): ClientUnaryCall;
  getProviderModels(
    request: GetProviderModelsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetProviderModelsResponse) => void,
  ): ClientUnaryCall;
  getProviderModels(
    request: GetProviderModelsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetProviderModelsResponse) => void,
  ): ClientUnaryCall;
  /** Complete a prompt (non-streaming) */
  completePrompt(
    request: CompletePromptRequest,
    callback: (error: ServiceError | null, response: CompletePromptResponse) => void,
  ): ClientUnaryCall;
  completePrompt(
    request: CompletePromptRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CompletePromptResponse) => void,
  ): ClientUnaryCall;
  completePrompt(
    request: CompletePromptRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CompletePromptResponse) => void,
  ): ClientUnaryCall;
  /** Stream a completion */
  streamCompletion(
    request: CompletePromptRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<CompletionChunk>;
  streamCompletion(
    request: CompletePromptRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<CompletionChunk>;
  /** Configure a provider */
  configureProvider(
    request: ConfigureProviderRequest,
    callback: (error: ServiceError | null, response: ConfigureProviderResponse) => void,
  ): ClientUnaryCall;
  configureProvider(
    request: ConfigureProviderRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ConfigureProviderResponse) => void,
  ): ClientUnaryCall;
  configureProvider(
    request: ConfigureProviderRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ConfigureProviderResponse) => void,
  ): ClientUnaryCall;
}

export const AIProviderServiceClient = makeGenericClientConstructor(
  AIProviderServiceService,
  "cline.AIProviderService",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AIProviderServiceClient;
  service: typeof AIProviderServiceService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
