// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.30.0
// source: diff.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "cline";

/** Request to create a diff */
export interface CreateDiffRequest {
  /** Original file content */
  originalContent: string;
  /** Modified file content */
  modifiedContent: string;
  /** File path (optional) */
  path: string;
}

/** Response with diff information */
export interface DiffResponse {
  /** The diff in unified format */
  diff: string;
  /** Individual file diffs */
  fileDiffs: FileDiff[];
  /** Error message if any */
  error: string;
}

/** Individual file diff */
export interface FileDiff {
  /** File path */
  path: string;
  /** Diff hunks */
  hunks: Hunk[];
}

/** Diff hunk */
export interface Hunk {
  /** Start line in original */
  originalStart: number;
  /** Number of lines in original */
  originalCount: number;
  /** Start line in modified */
  modifiedStart: number;
  /** Number of lines in modified */
  modifiedCount: number;
  /** Diff lines */
  lines: Line[];
}

/** Diff line */
export interface Line {
  /** Line type */
  type: Line_Type;
  /** Line content */
  content: string;
}

export enum Line_Type {
  CONTEXT = 0,
  ADDITION = 1,
  DELETION = 2,
  UNRECOGNIZED = -1,
}

export function line_TypeFromJSON(object: any): Line_Type {
  switch (object) {
    case 0:
    case "CONTEXT":
      return Line_Type.CONTEXT;
    case 1:
    case "ADDITION":
      return Line_Type.ADDITION;
    case 2:
    case "DELETION":
      return Line_Type.DELETION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Line_Type.UNRECOGNIZED;
  }
}

export function line_TypeToJSON(object: Line_Type): string {
  switch (object) {
    case Line_Type.CONTEXT:
      return "CONTEXT";
    case Line_Type.ADDITION:
      return "ADDITION";
    case Line_Type.DELETION:
      return "DELETION";
    case Line_Type.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Request to apply a diff */
export interface ApplyDiffRequest {
  /** File path */
  path: string;
  /** The diff to apply */
  diff: string;
  /** If true, don't actually apply the diff */
  dryRun: boolean;
}

/** Response from applying a diff */
export interface ApplyDiffResponse {
  /** Whether the diff was applied successfully */
  success: boolean;
  /** Resulting content after applying the diff */
  resultContent: string;
  /** Error message if any */
  error: string;
}

/** Request to create a checkpoint */
export interface CreateCheckpointRequest {
  /** Checkpoint message */
  message: string;
  /** Files to include (empty means all changes) */
  files: string[];
  /** Task ID (optional) */
  taskId: string;
}

/** Response from creating a checkpoint */
export interface CreateCheckpointResponse {
  /** Whether the checkpoint was created successfully */
  success: boolean;
  /** ID of the created checkpoint */
  checkpointId: string;
  /** Error message if any */
  error: string;
}

/** Request to list checkpoints */
export interface ListCheckpointsRequest {
  /** Task ID (optional) */
  taskId: string;
  /** Maximum number of checkpoints to return */
  limit: number;
}

/** Response with list of checkpoints */
export interface ListCheckpointsResponse {
  /** List of checkpoints */
  checkpoints: Checkpoint[];
  /** Error message if any */
  error: string;
}

/** Checkpoint information */
export interface Checkpoint {
  /** Checkpoint ID */
  id: string;
  /** Checkpoint message */
  message: string;
  /** Task ID */
  taskId: string;
  /** Timestamp (Unix time) */
  timestamp: number;
  /** Files changed in this checkpoint */
  changedFiles: string[];
}

/** Request to restore a checkpoint */
export interface RestoreCheckpointRequest {
  /** Checkpoint ID */
  checkpointId: string;
  /** Whether to force restore even if there are conflicts */
  force: boolean;
}

/** Response from restoring a checkpoint */
export interface RestoreCheckpointResponse {
  /** Whether the checkpoint was restored successfully */
  success: boolean;
  /** Error message if any */
  error: string;
}

/** Request to compare two checkpoints */
export interface CompareCheckpointsRequest {
  /** Base checkpoint ID */
  baseCheckpointId: string;
  /** Target checkpoint ID */
  targetCheckpointId: string;
}

/** Response from comparing two checkpoints */
export interface CompareCheckpointsResponse {
  /** Diffs for changed files */
  fileDiffs: FileDiff[];
  /** Error message if any */
  error: string;
}

function createBaseCreateDiffRequest(): CreateDiffRequest {
  return { originalContent: "", modifiedContent: "", path: "" };
}

export const CreateDiffRequest: MessageFns<CreateDiffRequest> = {
  encode(message: CreateDiffRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.originalContent !== "") {
      writer.uint32(10).string(message.originalContent);
    }
    if (message.modifiedContent !== "") {
      writer.uint32(18).string(message.modifiedContent);
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDiffRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDiffRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.originalContent = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modifiedContent = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDiffRequest {
    return {
      originalContent: isSet(object.originalContent) ? globalThis.String(object.originalContent) : "",
      modifiedContent: isSet(object.modifiedContent) ? globalThis.String(object.modifiedContent) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: CreateDiffRequest): unknown {
    const obj: any = {};
    if (message.originalContent !== "") {
      obj.originalContent = message.originalContent;
    }
    if (message.modifiedContent !== "") {
      obj.modifiedContent = message.modifiedContent;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateDiffRequest>, I>>(base?: I): CreateDiffRequest {
    return CreateDiffRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateDiffRequest>, I>>(object: I): CreateDiffRequest {
    const message = createBaseCreateDiffRequest();
    message.originalContent = object.originalContent ?? "";
    message.modifiedContent = object.modifiedContent ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseDiffResponse(): DiffResponse {
  return { diff: "", fileDiffs: [], error: "" };
}

export const DiffResponse: MessageFns<DiffResponse> = {
  encode(message: DiffResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.diff !== "") {
      writer.uint32(10).string(message.diff);
    }
    for (const v of message.fileDiffs) {
      FileDiff.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiffResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiffResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.diff = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileDiffs.push(FileDiff.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiffResponse {
    return {
      diff: isSet(object.diff) ? globalThis.String(object.diff) : "",
      fileDiffs: globalThis.Array.isArray(object?.fileDiffs)
        ? object.fileDiffs.map((e: any) => FileDiff.fromJSON(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: DiffResponse): unknown {
    const obj: any = {};
    if (message.diff !== "") {
      obj.diff = message.diff;
    }
    if (message.fileDiffs?.length) {
      obj.fileDiffs = message.fileDiffs.map((e) => FileDiff.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiffResponse>, I>>(base?: I): DiffResponse {
    return DiffResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiffResponse>, I>>(object: I): DiffResponse {
    const message = createBaseDiffResponse();
    message.diff = object.diff ?? "";
    message.fileDiffs = object.fileDiffs?.map((e) => FileDiff.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseFileDiff(): FileDiff {
  return { path: "", hunks: [] };
}

export const FileDiff: MessageFns<FileDiff> = {
  encode(message: FileDiff, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    for (const v of message.hunks) {
      Hunk.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileDiff {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileDiff();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.hunks.push(Hunk.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileDiff {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      hunks: globalThis.Array.isArray(object?.hunks) ? object.hunks.map((e: any) => Hunk.fromJSON(e)) : [],
    };
  },

  toJSON(message: FileDiff): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.hunks?.length) {
      obj.hunks = message.hunks.map((e) => Hunk.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileDiff>, I>>(base?: I): FileDiff {
    return FileDiff.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileDiff>, I>>(object: I): FileDiff {
    const message = createBaseFileDiff();
    message.path = object.path ?? "";
    message.hunks = object.hunks?.map((e) => Hunk.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHunk(): Hunk {
  return { originalStart: 0, originalCount: 0, modifiedStart: 0, modifiedCount: 0, lines: [] };
}

export const Hunk: MessageFns<Hunk> = {
  encode(message: Hunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.originalStart !== 0) {
      writer.uint32(8).int32(message.originalStart);
    }
    if (message.originalCount !== 0) {
      writer.uint32(16).int32(message.originalCount);
    }
    if (message.modifiedStart !== 0) {
      writer.uint32(24).int32(message.modifiedStart);
    }
    if (message.modifiedCount !== 0) {
      writer.uint32(32).int32(message.modifiedCount);
    }
    for (const v of message.lines) {
      Line.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Hunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.originalStart = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.originalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.modifiedStart = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.modifiedCount = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lines.push(Line.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hunk {
    return {
      originalStart: isSet(object.originalStart) ? globalThis.Number(object.originalStart) : 0,
      originalCount: isSet(object.originalCount) ? globalThis.Number(object.originalCount) : 0,
      modifiedStart: isSet(object.modifiedStart) ? globalThis.Number(object.modifiedStart) : 0,
      modifiedCount: isSet(object.modifiedCount) ? globalThis.Number(object.modifiedCount) : 0,
      lines: globalThis.Array.isArray(object?.lines) ? object.lines.map((e: any) => Line.fromJSON(e)) : [],
    };
  },

  toJSON(message: Hunk): unknown {
    const obj: any = {};
    if (message.originalStart !== 0) {
      obj.originalStart = Math.round(message.originalStart);
    }
    if (message.originalCount !== 0) {
      obj.originalCount = Math.round(message.originalCount);
    }
    if (message.modifiedStart !== 0) {
      obj.modifiedStart = Math.round(message.modifiedStart);
    }
    if (message.modifiedCount !== 0) {
      obj.modifiedCount = Math.round(message.modifiedCount);
    }
    if (message.lines?.length) {
      obj.lines = message.lines.map((e) => Line.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Hunk>, I>>(base?: I): Hunk {
    return Hunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Hunk>, I>>(object: I): Hunk {
    const message = createBaseHunk();
    message.originalStart = object.originalStart ?? 0;
    message.originalCount = object.originalCount ?? 0;
    message.modifiedStart = object.modifiedStart ?? 0;
    message.modifiedCount = object.modifiedCount ?? 0;
    message.lines = object.lines?.map((e) => Line.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLine(): Line {
  return { type: 0, content: "" };
}

export const Line: MessageFns<Line> = {
  encode(message: Line, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Line {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLine();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Line {
    return {
      type: isSet(object.type) ? line_TypeFromJSON(object.type) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
    };
  },

  toJSON(message: Line): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = line_TypeToJSON(message.type);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Line>, I>>(base?: I): Line {
    return Line.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Line>, I>>(object: I): Line {
    const message = createBaseLine();
    message.type = object.type ?? 0;
    message.content = object.content ?? "";
    return message;
  },
};

function createBaseApplyDiffRequest(): ApplyDiffRequest {
  return { path: "", diff: "", dryRun: false };
}

export const ApplyDiffRequest: MessageFns<ApplyDiffRequest> = {
  encode(message: ApplyDiffRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.diff !== "") {
      writer.uint32(18).string(message.diff);
    }
    if (message.dryRun !== false) {
      writer.uint32(24).bool(message.dryRun);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyDiffRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyDiffRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.diff = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.dryRun = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyDiffRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      diff: isSet(object.diff) ? globalThis.String(object.diff) : "",
      dryRun: isSet(object.dryRun) ? globalThis.Boolean(object.dryRun) : false,
    };
  },

  toJSON(message: ApplyDiffRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.diff !== "") {
      obj.diff = message.diff;
    }
    if (message.dryRun !== false) {
      obj.dryRun = message.dryRun;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplyDiffRequest>, I>>(base?: I): ApplyDiffRequest {
    return ApplyDiffRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplyDiffRequest>, I>>(object: I): ApplyDiffRequest {
    const message = createBaseApplyDiffRequest();
    message.path = object.path ?? "";
    message.diff = object.diff ?? "";
    message.dryRun = object.dryRun ?? false;
    return message;
  },
};

function createBaseApplyDiffResponse(): ApplyDiffResponse {
  return { success: false, resultContent: "", error: "" };
}

export const ApplyDiffResponse: MessageFns<ApplyDiffResponse> = {
  encode(message: ApplyDiffResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.resultContent !== "") {
      writer.uint32(18).string(message.resultContent);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplyDiffResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplyDiffResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resultContent = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplyDiffResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      resultContent: isSet(object.resultContent) ? globalThis.String(object.resultContent) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ApplyDiffResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.resultContent !== "") {
      obj.resultContent = message.resultContent;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplyDiffResponse>, I>>(base?: I): ApplyDiffResponse {
    return ApplyDiffResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplyDiffResponse>, I>>(object: I): ApplyDiffResponse {
    const message = createBaseApplyDiffResponse();
    message.success = object.success ?? false;
    message.resultContent = object.resultContent ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseCreateCheckpointRequest(): CreateCheckpointRequest {
  return { message: "", files: [], taskId: "" };
}

export const CreateCheckpointRequest: MessageFns<CreateCheckpointRequest> = {
  encode(message: CreateCheckpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    for (const v of message.files) {
      writer.uint32(18).string(v!);
    }
    if (message.taskId !== "") {
      writer.uint32(26).string(message.taskId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCheckpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCheckpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.files.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCheckpointRequest {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => globalThis.String(e)) : [],
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
    };
  },

  toJSON(message: CreateCheckpointRequest): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.files?.length) {
      obj.files = message.files;
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCheckpointRequest>, I>>(base?: I): CreateCheckpointRequest {
    return CreateCheckpointRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCheckpointRequest>, I>>(object: I): CreateCheckpointRequest {
    const message = createBaseCreateCheckpointRequest();
    message.message = object.message ?? "";
    message.files = object.files?.map((e) => e) || [];
    message.taskId = object.taskId ?? "";
    return message;
  },
};

function createBaseCreateCheckpointResponse(): CreateCheckpointResponse {
  return { success: false, checkpointId: "", error: "" };
}

export const CreateCheckpointResponse: MessageFns<CreateCheckpointResponse> = {
  encode(message: CreateCheckpointResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.checkpointId !== "") {
      writer.uint32(18).string(message.checkpointId);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateCheckpointResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCheckpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.checkpointId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateCheckpointResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      checkpointId: isSet(object.checkpointId) ? globalThis.String(object.checkpointId) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: CreateCheckpointResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.checkpointId !== "") {
      obj.checkpointId = message.checkpointId;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateCheckpointResponse>, I>>(base?: I): CreateCheckpointResponse {
    return CreateCheckpointResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateCheckpointResponse>, I>>(object: I): CreateCheckpointResponse {
    const message = createBaseCreateCheckpointResponse();
    message.success = object.success ?? false;
    message.checkpointId = object.checkpointId ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseListCheckpointsRequest(): ListCheckpointsRequest {
  return { taskId: "", limit: 0 };
}

export const ListCheckpointsRequest: MessageFns<ListCheckpointsRequest> = {
  encode(message: ListCheckpointsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCheckpointsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCheckpointsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCheckpointsRequest {
    return {
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
    };
  },

  toJSON(message: ListCheckpointsRequest): unknown {
    const obj: any = {};
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCheckpointsRequest>, I>>(base?: I): ListCheckpointsRequest {
    return ListCheckpointsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCheckpointsRequest>, I>>(object: I): ListCheckpointsRequest {
    const message = createBaseListCheckpointsRequest();
    message.taskId = object.taskId ?? "";
    message.limit = object.limit ?? 0;
    return message;
  },
};

function createBaseListCheckpointsResponse(): ListCheckpointsResponse {
  return { checkpoints: [], error: "" };
}

export const ListCheckpointsResponse: MessageFns<ListCheckpointsResponse> = {
  encode(message: ListCheckpointsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.checkpoints) {
      Checkpoint.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListCheckpointsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCheckpointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.checkpoints.push(Checkpoint.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListCheckpointsResponse {
    return {
      checkpoints: globalThis.Array.isArray(object?.checkpoints)
        ? object.checkpoints.map((e: any) => Checkpoint.fromJSON(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ListCheckpointsResponse): unknown {
    const obj: any = {};
    if (message.checkpoints?.length) {
      obj.checkpoints = message.checkpoints.map((e) => Checkpoint.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListCheckpointsResponse>, I>>(base?: I): ListCheckpointsResponse {
    return ListCheckpointsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListCheckpointsResponse>, I>>(object: I): ListCheckpointsResponse {
    const message = createBaseListCheckpointsResponse();
    message.checkpoints = object.checkpoints?.map((e) => Checkpoint.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseCheckpoint(): Checkpoint {
  return { id: "", message: "", taskId: "", timestamp: 0, changedFiles: [] };
}

export const Checkpoint: MessageFns<Checkpoint> = {
  encode(message: Checkpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    if (message.taskId !== "") {
      writer.uint32(26).string(message.taskId);
    }
    if (message.timestamp !== 0) {
      writer.uint32(32).int64(message.timestamp);
    }
    for (const v of message.changedFiles) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Checkpoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckpoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.timestamp = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.changedFiles.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Checkpoint {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      taskId: isSet(object.taskId) ? globalThis.String(object.taskId) : "",
      timestamp: isSet(object.timestamp) ? globalThis.Number(object.timestamp) : 0,
      changedFiles: globalThis.Array.isArray(object?.changedFiles)
        ? object.changedFiles.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Checkpoint): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.taskId !== "") {
      obj.taskId = message.taskId;
    }
    if (message.timestamp !== 0) {
      obj.timestamp = Math.round(message.timestamp);
    }
    if (message.changedFiles?.length) {
      obj.changedFiles = message.changedFiles;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Checkpoint>, I>>(base?: I): Checkpoint {
    return Checkpoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Checkpoint>, I>>(object: I): Checkpoint {
    const message = createBaseCheckpoint();
    message.id = object.id ?? "";
    message.message = object.message ?? "";
    message.taskId = object.taskId ?? "";
    message.timestamp = object.timestamp ?? 0;
    message.changedFiles = object.changedFiles?.map((e) => e) || [];
    return message;
  },
};

function createBaseRestoreCheckpointRequest(): RestoreCheckpointRequest {
  return { checkpointId: "", force: false };
}

export const RestoreCheckpointRequest: MessageFns<RestoreCheckpointRequest> = {
  encode(message: RestoreCheckpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.checkpointId !== "") {
      writer.uint32(10).string(message.checkpointId);
    }
    if (message.force !== false) {
      writer.uint32(16).bool(message.force);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestoreCheckpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestoreCheckpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.checkpointId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.force = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestoreCheckpointRequest {
    return {
      checkpointId: isSet(object.checkpointId) ? globalThis.String(object.checkpointId) : "",
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
    };
  },

  toJSON(message: RestoreCheckpointRequest): unknown {
    const obj: any = {};
    if (message.checkpointId !== "") {
      obj.checkpointId = message.checkpointId;
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RestoreCheckpointRequest>, I>>(base?: I): RestoreCheckpointRequest {
    return RestoreCheckpointRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RestoreCheckpointRequest>, I>>(object: I): RestoreCheckpointRequest {
    const message = createBaseRestoreCheckpointRequest();
    message.checkpointId = object.checkpointId ?? "";
    message.force = object.force ?? false;
    return message;
  },
};

function createBaseRestoreCheckpointResponse(): RestoreCheckpointResponse {
  return { success: false, error: "" };
}

export const RestoreCheckpointResponse: MessageFns<RestoreCheckpointResponse> = {
  encode(message: RestoreCheckpointResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RestoreCheckpointResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRestoreCheckpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RestoreCheckpointResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: RestoreCheckpointResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RestoreCheckpointResponse>, I>>(base?: I): RestoreCheckpointResponse {
    return RestoreCheckpointResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RestoreCheckpointResponse>, I>>(object: I): RestoreCheckpointResponse {
    const message = createBaseRestoreCheckpointResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseCompareCheckpointsRequest(): CompareCheckpointsRequest {
  return { baseCheckpointId: "", targetCheckpointId: "" };
}

export const CompareCheckpointsRequest: MessageFns<CompareCheckpointsRequest> = {
  encode(message: CompareCheckpointsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseCheckpointId !== "") {
      writer.uint32(10).string(message.baseCheckpointId);
    }
    if (message.targetCheckpointId !== "") {
      writer.uint32(18).string(message.targetCheckpointId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompareCheckpointsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompareCheckpointsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseCheckpointId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetCheckpointId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompareCheckpointsRequest {
    return {
      baseCheckpointId: isSet(object.baseCheckpointId) ? globalThis.String(object.baseCheckpointId) : "",
      targetCheckpointId: isSet(object.targetCheckpointId) ? globalThis.String(object.targetCheckpointId) : "",
    };
  },

  toJSON(message: CompareCheckpointsRequest): unknown {
    const obj: any = {};
    if (message.baseCheckpointId !== "") {
      obj.baseCheckpointId = message.baseCheckpointId;
    }
    if (message.targetCheckpointId !== "") {
      obj.targetCheckpointId = message.targetCheckpointId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompareCheckpointsRequest>, I>>(base?: I): CompareCheckpointsRequest {
    return CompareCheckpointsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompareCheckpointsRequest>, I>>(object: I): CompareCheckpointsRequest {
    const message = createBaseCompareCheckpointsRequest();
    message.baseCheckpointId = object.baseCheckpointId ?? "";
    message.targetCheckpointId = object.targetCheckpointId ?? "";
    return message;
  },
};

function createBaseCompareCheckpointsResponse(): CompareCheckpointsResponse {
  return { fileDiffs: [], error: "" };
}

export const CompareCheckpointsResponse: MessageFns<CompareCheckpointsResponse> = {
  encode(message: CompareCheckpointsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.fileDiffs) {
      FileDiff.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CompareCheckpointsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCompareCheckpointsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileDiffs.push(FileDiff.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CompareCheckpointsResponse {
    return {
      fileDiffs: globalThis.Array.isArray(object?.fileDiffs)
        ? object.fileDiffs.map((e: any) => FileDiff.fromJSON(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: CompareCheckpointsResponse): unknown {
    const obj: any = {};
    if (message.fileDiffs?.length) {
      obj.fileDiffs = message.fileDiffs.map((e) => FileDiff.toJSON(e));
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CompareCheckpointsResponse>, I>>(base?: I): CompareCheckpointsResponse {
    return CompareCheckpointsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CompareCheckpointsResponse>, I>>(object: I): CompareCheckpointsResponse {
    const message = createBaseCompareCheckpointsResponse();
    message.fileDiffs = object.fileDiffs?.map((e) => FileDiff.fromPartial(e)) || [];
    message.error = object.error ?? "";
    return message;
  },
};

/** DiffService for managing file diffs and version control operations */
export type DiffServiceService = typeof DiffServiceService;
export const DiffServiceService = {
  /** Create a diff between two file contents */
  createDiff: {
    path: "/cline.DiffService/CreateDiff",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateDiffRequest) => Buffer.from(CreateDiffRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateDiffRequest.decode(value),
    responseSerialize: (value: DiffResponse) => Buffer.from(DiffResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DiffResponse.decode(value),
  },
  /** Apply a diff to a file */
  applyDiff: {
    path: "/cline.DiffService/ApplyDiff",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ApplyDiffRequest) => Buffer.from(ApplyDiffRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ApplyDiffRequest.decode(value),
    responseSerialize: (value: ApplyDiffResponse) => Buffer.from(ApplyDiffResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ApplyDiffResponse.decode(value),
  },
  /** Create a checkpoint (commit changes) */
  createCheckpoint: {
    path: "/cline.DiffService/CreateCheckpoint",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCheckpointRequest) => Buffer.from(CreateCheckpointRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateCheckpointRequest.decode(value),
    responseSerialize: (value: CreateCheckpointResponse) =>
      Buffer.from(CreateCheckpointResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateCheckpointResponse.decode(value),
  },
  /** List checkpoints */
  listCheckpoints: {
    path: "/cline.DiffService/ListCheckpoints",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListCheckpointsRequest) => Buffer.from(ListCheckpointsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListCheckpointsRequest.decode(value),
    responseSerialize: (value: ListCheckpointsResponse) => Buffer.from(ListCheckpointsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListCheckpointsResponse.decode(value),
  },
  /** Restore to a checkpoint */
  restoreCheckpoint: {
    path: "/cline.DiffService/RestoreCheckpoint",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RestoreCheckpointRequest) => Buffer.from(RestoreCheckpointRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RestoreCheckpointRequest.decode(value),
    responseSerialize: (value: RestoreCheckpointResponse) =>
      Buffer.from(RestoreCheckpointResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RestoreCheckpointResponse.decode(value),
  },
  /** Compare two checkpoints */
  compareCheckpoints: {
    path: "/cline.DiffService/CompareCheckpoints",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CompareCheckpointsRequest) =>
      Buffer.from(CompareCheckpointsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CompareCheckpointsRequest.decode(value),
    responseSerialize: (value: CompareCheckpointsResponse) =>
      Buffer.from(CompareCheckpointsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CompareCheckpointsResponse.decode(value),
  },
} as const;

export interface DiffServiceServer extends UntypedServiceImplementation {
  /** Create a diff between two file contents */
  createDiff: handleUnaryCall<CreateDiffRequest, DiffResponse>;
  /** Apply a diff to a file */
  applyDiff: handleUnaryCall<ApplyDiffRequest, ApplyDiffResponse>;
  /** Create a checkpoint (commit changes) */
  createCheckpoint: handleUnaryCall<CreateCheckpointRequest, CreateCheckpointResponse>;
  /** List checkpoints */
  listCheckpoints: handleUnaryCall<ListCheckpointsRequest, ListCheckpointsResponse>;
  /** Restore to a checkpoint */
  restoreCheckpoint: handleUnaryCall<RestoreCheckpointRequest, RestoreCheckpointResponse>;
  /** Compare two checkpoints */
  compareCheckpoints: handleUnaryCall<CompareCheckpointsRequest, CompareCheckpointsResponse>;
}

export interface DiffServiceClient extends Client {
  /** Create a diff between two file contents */
  createDiff(
    request: CreateDiffRequest,
    callback: (error: ServiceError | null, response: DiffResponse) => void,
  ): ClientUnaryCall;
  createDiff(
    request: CreateDiffRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DiffResponse) => void,
  ): ClientUnaryCall;
  createDiff(
    request: CreateDiffRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DiffResponse) => void,
  ): ClientUnaryCall;
  /** Apply a diff to a file */
  applyDiff(
    request: ApplyDiffRequest,
    callback: (error: ServiceError | null, response: ApplyDiffResponse) => void,
  ): ClientUnaryCall;
  applyDiff(
    request: ApplyDiffRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ApplyDiffResponse) => void,
  ): ClientUnaryCall;
  applyDiff(
    request: ApplyDiffRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ApplyDiffResponse) => void,
  ): ClientUnaryCall;
  /** Create a checkpoint (commit changes) */
  createCheckpoint(
    request: CreateCheckpointRequest,
    callback: (error: ServiceError | null, response: CreateCheckpointResponse) => void,
  ): ClientUnaryCall;
  createCheckpoint(
    request: CreateCheckpointRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateCheckpointResponse) => void,
  ): ClientUnaryCall;
  createCheckpoint(
    request: CreateCheckpointRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateCheckpointResponse) => void,
  ): ClientUnaryCall;
  /** List checkpoints */
  listCheckpoints(
    request: ListCheckpointsRequest,
    callback: (error: ServiceError | null, response: ListCheckpointsResponse) => void,
  ): ClientUnaryCall;
  listCheckpoints(
    request: ListCheckpointsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListCheckpointsResponse) => void,
  ): ClientUnaryCall;
  listCheckpoints(
    request: ListCheckpointsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListCheckpointsResponse) => void,
  ): ClientUnaryCall;
  /** Restore to a checkpoint */
  restoreCheckpoint(
    request: RestoreCheckpointRequest,
    callback: (error: ServiceError | null, response: RestoreCheckpointResponse) => void,
  ): ClientUnaryCall;
  restoreCheckpoint(
    request: RestoreCheckpointRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RestoreCheckpointResponse) => void,
  ): ClientUnaryCall;
  restoreCheckpoint(
    request: RestoreCheckpointRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RestoreCheckpointResponse) => void,
  ): ClientUnaryCall;
  /** Compare two checkpoints */
  compareCheckpoints(
    request: CompareCheckpointsRequest,
    callback: (error: ServiceError | null, response: CompareCheckpointsResponse) => void,
  ): ClientUnaryCall;
  compareCheckpoints(
    request: CompareCheckpointsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CompareCheckpointsResponse) => void,
  ): ClientUnaryCall;
  compareCheckpoints(
    request: CompareCheckpointsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CompareCheckpointsResponse) => void,
  ): ClientUnaryCall;
}

export const DiffServiceClient = makeGenericClientConstructor(DiffServiceService, "cline.DiffService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): DiffServiceClient;
  service: typeof DiffServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
