# Guide: Migrating WebviewMessage to gRPC in Cline

This guide outlines the general process for migrating WebviewMessage and ExtensionMessage interactions to the gRPC event bus in Cline. This approach increases consistency, provides better type safety, and improves maintainability.

## Message Flow Architecture

Cline uses a bi-directional communication system between the frontend (webview) and backend (extension):

1. **WebviewMessage**: Messages sent FROM the webview TO the extension
   - Defined in `src/shared/WebviewMessage.ts`
   - Initiated by user actions in the UI
   - Sent using `vscode.postMessage({type: "someMessageType", ...})`
   - Processed by the switch statement in `controller/index.ts`

2. **ExtensionMessage**: Messages sent FROM the extension TO the webview
   - Defined in `src/shared/ExtensionMessage.ts`
   - Usually responses to WebviewMessages or state updates
   - Sent using `postMessageToWebview({type: "someResponseType", ...})`
   - Captured by event listeners in the frontend

3. **State Management**:
   - `ExtensionStateContext` serves as the React context for managing state
   - Listens for ExtensionMessages and updates React state accordingly
   - Components consume this state via `useExtensionState()`

The gRPC migration replaces these direct message types with a unified approach:
- All requests go through generic "grpc_request" messages
- All responses come back as "grpc_response" messages
- Service/method information determines the actual operation

## Codebase Organization

Understanding the organization of the Cline codebase is essential for successful migrations:

### Proto Files
- **Location**: `/proto/`
- **Structure**: One `.proto` file per service (e.g., `mcp.proto`, `file.proto`, `state.proto`)
- **Purpose**: Defines the service interfaces, RPC methods, and message types
- **Common Types**: Shared types like `Metadata` are defined in `common.proto`

### Backend (Extension)

- **Controller**:
  - **Main Controller**: `/src/core/controller/index.ts` - Contains the switch statement handling all WebviewMessages
  - **Service Handlers**: `/src/core/controller/{service-name}/` - Directories for each service with RPC implementations
  - **Service Registration**: `/src/core/controller/{service-name}/methods.ts` - Registers all RPC methods for a service
  - **Method Implementations**: `/src/core/controller/{service-name}/{method-name}.ts` - Individual RPC handler files

- **gRPC Infrastructure**:
  - **Service Registry**: `/src/core/controller/grpc-service.ts` - Creates service registries
  - **gRPC Handler**: `/src/core/controller/grpc-handler.ts` - Handles incoming gRPC requests
  - **Service Config**: `/src/core/controller/grpc-service-config.ts` - Maps service names to handlers

### Frontend (Webview UI)

- **React Components**: `/webview-ui/src/components/` - UI components organized by feature
- **gRPC Clients**: `/webview-ui/src/services/grpc-client.ts` - Client-side service interfaces
- **gRPC Base Client**: `/webview-ui/src/services/grpc-client-base.ts` - Base implementation for gRPC clients
- **Context Providers**: `/webview-ui/src/context/ExtensionStateContext.tsx` - Manages state and message handling

### Shared Types

- **Proto Generated Types**: `/src/shared/proto/` - TypeScript interfaces generated from proto files
- **Application Types**: `/src/shared/` - Application-specific interface definitions
- **Type Conversions**: `/src/shared/proto-conversions/` - Utilities to convert between proto and app types

## Auto-Generated Files

When working with the gRPC migration, you'll encounter several auto-generated files that **should never be modified directly**:

1. **Service Method Registration Files**: Files like `src/core/controller/{service-name}/methods.ts` that register the RPC methods
2. **Proto TypeScript Definitions**: Files in `src/shared/proto/` that define interfaces generated from proto files
3. **gRPC Service Configs**: Files like `src/core/controller/grpc-service-config.ts`

These files are regenerated by the build script whenever proto files are updated. You can identify them by a comment at the top:

```typescript
// AUTO-GENERATED FILE - DO NOT MODIFY DIRECTLY
// Generated by proto/build-proto.js
```

Instead of editing these files directly, you should:
1. Update the `.proto` files in the `/proto` directory
2. Run the build script to regenerate all dependent files
3. Create implementation files that will be imported by the auto-generated code

## Handling Core Logic During Migration

When migrating from WebviewMessage to gRPC, it's crucial to understand how the existing core logic works, especially how it interacts with the current message passing system.

### Creating RPC Variants for State-Updating Methods

Most WebviewMessage handlers call methods in service classes that not only perform the requested operation but also send ExtensionMessages back to the webview to update state. This creates a problem for gRPC handlers which need to return results directly instead of sending separate messages.

For example, in the MCP system:

```typescript
// In McpHub.ts (core logic)
async restartConnection(serverName: string): Promise<void> {
  // ... operation logic ...
  
  // This sends an ExtensionMessage back to the webview
  await this.notifyWebviewOfServerChanges() 
}
```

When migrating this to gRPC, you need to:

1. **Examine the core method** to see if it calls functions like `notifyWebviewOfServerChanges()`, `postMessageToWebview()`, or similar that would duplicate your gRPC response
   
2. **Create an RPC variant** of the method that performs the same operation but returns data directly instead of sending messages:

```typescript
// RPC variant to use with gRPC handlers
async restartConnectionRPC(serverName: string): Promise<McpServer[]> {
  // Same operation logic as restartConnection
  this.isConnecting = true;
  const connection = this.connections.find((conn) => conn.server.name === serverName);
  // ... (rest of operation logic) ...
  
  // Instead of notifyWebviewOfServerChanges(), return the data directly
  return this.getServers();
}
```

3. **Use the RPC variant in your gRPC handler**:

```typescript
export async function restartMcpServer(controller: Controller, request: RestartMcpServerRequest): Promise<McpServers> {
  // Call the RPC variant that doesn't send messages
  const mcpServers = await controller.mcpHub?.restartConnectionRPC(request.serverName) || [];
  
  // Convert and return the data
  const protoServers = convertMcpServersToProtoMcpServers(mcpServers);
  return { mcpServers: protoServers };
}
```

## Migration Process Overview

### 1. Define the gRPC Method in Proto File

For each message type you want to migrate, add a new RPC method to the appropriate service proto file:

```protobuf
service YourService {
  // Existing RPC methods...
  rpc yourOperation(YourOperationRequest) returns (YourOperationResponse);
}

// Define a dedicated request message with appropriate fields
message YourOperationRequest {
  Metadata metadata = 1;
  string parameter_one = 2;
  bool parameter_two = 3;
  // ...other fields as needed
}

// Define the response message with appropriate fields
message YourOperationResponse {
  repeated YourEntity entities = 1;
  // ...other fields as needed
}
```

### 2. Run Proto Build Script

After updating the proto file, generate the TypeScript interfaces:

```bash
node proto/build-proto.js
```

This creates/updates the necessary TypeScript definitions in `src/shared/proto/` and automatically regenerates service registration files like `methods.ts`. The build script will:

1. Generate TypeScript interfaces from your proto definitions 
2. Update service method registration files
3. Update gRPC service configuration files
4. Create or update client-side service definitions

### 3. Implement the Service Handler

Create a handler file in `src/core/controller/your-service/`:

```typescript
import type { YourOperationRequest, YourOperationResponse } from "../../../shared/proto/your-service"
import type { Controller } from "../index"
import { convertApplicationTypesToProtoTypes } from "../../../shared/proto-conversions/your-service/your-conversion"

/**
 * Handles the operation
 * @param controller The controller instance
 * @param request The operation request
 * @returns The operation response
 */
export async function yourOperation(controller: Controller, request: YourOperationRequest): Promise<YourOperationResponse> {
  try {
    // Implement the operation logic, often calling an existing Controller method
    const result = await controller.yourSubsystem?.yourExistingMethod(request.parameterOne, request.parameterTwo)
    
    // Convert application types to protobuf types
    const protoEntities = convertApplicationTypesToProtoTypes(result)
    
    return { entities: protoEntities }
  } catch (error) {
    console.error(`Failed to perform operation: ${error}`)
    throw error
  }
}
```

### 4. Register the Method

Locate the methods registration file (e.g., `src/core/controller/your-service/methods.ts`) and add your new method:

```typescript
// Import your method
import { yourOperation } from "./yourOperation"

export function registerAllMethods(): void {
  // Register existing methods...
  registerMethod("yourOperation", yourOperation)
}
```

The method registration connects your implementation to the gRPC service registry, which is automatically wired up to handle incoming requests via `grpc-service-config.ts`.

### 5. Update Frontend Code

Find components that use `vscode.postMessage()` for the operation and update them:

```typescript
// Old approach using WebviewMessage
const handleOperation = () => {
  vscode.postMessage({
    type: "yourOperationMessage",
    paramOne: value1,
    paramTwo: value2
  })
}

// New approach using gRPC
const handleOperation = () => {
  YourServiceClient.yourOperation({
    parameterOne: value1,
    parameterTwo: value2
  })
    .then((response) => {
      // Convert proto types back to application types if needed
      const entities = convertProtoTypesToApplicationTypes(response.entities)
      
      // Update state/UI
      setEntities(entities)
    })
    .catch((error) => {
      console.error("Operation failed", error)
    })
}
```

The service clients (`YourServiceClient`) are auto-generated from the proto files and exported from `webview-ui/src/services/grpc-client.ts`.

### 6. Update ExtensionStateContext (if needed)

In some cases, you might need to update the ExtensionStateContext if it was previously handling extension messages related to this operation:

```typescript
// Old approach: listening for extension message
useEvent("message", (event) => {
  const message = event.data
  if (message.type === "operationResult") {
    setEntities(message.entities)
  }
})

// New approach: direct state updates in component
// No need for ExtensionStateContext to handle this specific message type
```

### 7. Clean Up Old Code

1. Remove the message handler case from `src/core/controller/index.ts`:

```typescript
// Delete this block
case "yourOperationMessage": {
  try {
    await this.yourSubsystem?.yourExistingMethod(message.paramOne!, message.paramTwo!)
  } catch (error) {
    console.error(`Failed to perform operation: ${error}`)
  }
  break;
}
```

2. Remove the message type from `src/shared/WebviewMessage.ts`:

```typescript
export interface WebviewMessage {
  type:
    | "apiConfiguration"
    | "webviewDidLaunch"
    // ... other message types
    // remove this line: | "yourOperationMessage"
    // ... remaining message types
}
```

3. If applicable, remove the extension message type from `src/shared/ExtensionMessage.ts`:

```typescript
export interface ExtensionMessage {
  type:
    | "action"
    | "state"
    // ... other message types
    // remove this line: | "operationResult"
    // ... remaining message types
}
```

## Understanding Type Conversions

### Why Type Conversions Are Needed

Type conversions are temporarily necessary during the migration because Cline currently maintains two parallel type systems:

1. **Application Types** (`/src/shared/*.ts`): 
   - These are the original TypeScript interfaces designed for the application
   - Optimized for developer experience with TypeScript idioms
   - May use undefined for optional values, complex type unions, etc.
   - Have evolved organically with the application's needs

2. **Proto-Generated Types** (`/src/shared/proto/*.ts`):
   - Automatically generated from `.proto` files
   - Follow Protocol Buffers conventions
   - Have stricter rules about required/optional fields
   - Use string defaults instead of undefined
   - May have different naming conventions

**Long-term Goal**: Eventually, Cline will fully migrate to using only the proto-generated types throughout the codebase, eliminating the need for these conversions. However, during the transition period, these conversion utilities allow us to:
1. Migrate to gRPC incrementally without rewriting the entire application at once
2. Maintain backward compatibility with existing code
3. Preserve the developer experience with familiar types

**When conversions are necessary:**
- When the application has existing types with different structures than proto types
- When optional values are handled differently (undefined vs. empty string)
- When types include nested objects that need recursive conversion
- When enums are represented differently (string literals vs. numeric enums)

**When conversions can be skipped:**
- For simple messages with primitive types only
- When designing new features where you can align application types with proto types
- When the proto types can serve as the application types directly

### Conversion Patterns

Most gRPC migrations require type conversions in two directions:

1. **Backend (Controller to Proto)**: Convert application types to protobuf format
   - All required fields must be present
   - Optional fields must be explicitly defined
   - Nested objects need special handling 
   - Convert TypeScript idioms (undefined, null) to protobuf conventions

2. **Frontend (Proto to Application)**: Convert protobuf responses to application types
   - Empty strings may need conversion to undefined
   - Special handling for defaults and nullability
   - Nested objects require recursive conversion
   - Convert numeric enums back to string literals

Each service typically has its own conversion utility module in `src/shared/proto-conversions/`.

### Example Type Conversion

Consider an MCP server example:

**Application Type (McpServer in src/shared/mcp.ts):**
```typescript
interface McpServer {
  name: string;
  config: string;
  status: "connected" | "connecting" | "disconnected";
  error?: string;
  tools?: McpTool[];
  // ...other fields
}
```

**Proto Type (in src/shared/proto/mcp.ts):**
```typescript
interface McpServer {
  name: string;
  config: string;
  status: McpServerStatus; // numeric enum
  error: string; // required with empty string default
  tools: McpTool[]; // always present, possibly empty array
  // ...other fields
}
```

The conversion functions handle these differences:
```typescript
// Application -> Proto conversion
function convertMcpServersToProtoMcpServers(mcpServers: McpServer[]): ProtoMcpServer[] {
  return mcpServers.map(server => ({
    // Convert string literal status to numeric enum
    status: convertStatusToEnum(server.status),
    
    // Ensure optional fields have appropriate defaults
    error: server.error || "",
    tools: server.tools || [],
    
    // Pass through fields that don't need conversion
    name: server.name,
    config: server.config,
    // ...other fields
  }));
}

// Proto -> Application conversion
function convertProtoMcpServersToMcpServers(protoServers: ProtoMcpServer[]): McpServer[] {
  return protoServers.map(protoServer => ({
    // Convert numeric enum to string literal
    status: convertEnumToStatus(protoServer.status),
    
    // Convert empty strings to undefined
    error: protoServer.error === "" ? undefined : protoServer.error,
    
    // Pass through fields that don't need conversion
    name: protoServer.name,
    config: protoServer.config,
    tools: protoServer.tools, // Array is kept as-is
    // ...other fields
  }));
}
```

## Managing Frontend State

When migrating from WebviewMessage to gRPC, you'll often encounter a significant change in how UI state is managed. In the traditional WebviewMessage approach, the backend often sent intermediate state updates to the frontend. With gRPC, you typically only get a single response at the end of an operation.

### Local UI State Management

A common pattern in the WebviewMessage approach was:
1. Frontend sends a message requesting an operation
2. Backend immediately updates state (e.g., "connecting", "loading", "processing")
3. Backend notifies the frontend of this intermediate state
4. Backend completes the operation
5. Backend sends the final state

With gRPC, this changes to:
1. Frontend sends a gRPC request
2. Backend processes the request completely
3. Backend returns the final result
4. Frontend receives only the final state

This means **you need to manage transitional UI states locally in your frontend components**. For example, when restarting an MCP server:

```typescript
// Old approach with WebviewMessage
const handleRestart = () => {
  vscode.postMessage({
    type: "restartMcpServer", 
    text: server.name,
  })
  // Backend would set status to "connecting" and notify frontend
}

// New approach with gRPC
const handleRestart = () => {
  // Set local state for UI feedback
  setIsRestarting(true);
  
  McpServiceClient.restartMcpServer({
    serverName: server.name,
  })
    .then((response) => {
      const mcpServers = convertProtoMcpServersToMcpServers(response.mcpServers);
      setMcpServers(mcpServers);
      setIsRestarting(false);
    })
    .catch((error) => {
      setIsRestarting(false);
      console.error("Error restarting MCP server", error);
    });
}
```

In your UI rendering, you would then consider both the server status and the local isRestarting state:

```jsx
<Button 
  disabled={server.status === "connecting" || isRestarting}
>
  {server.status === "connecting" || isRestarting ? "Restarting..." : "Restart Server"}
</Button>
```

This pattern:
- Provides immediate feedback to users
- Decouples UI concerns from the backend
- Creates a more maintainable architecture
- Reduces unnecessary network traffic

## Complete Message Flow: Before and After Migration

### Before Migration (Traditional Message Flow)

1. **Webview Initiates Action**:
   - User clicks a button in a React component
   - Component calls `vscode.postMessage({type: "restartMcpServer", text: serverName})`

2. **Extension Processes WebviewMessage**:
   - Controller's handleWebviewMessage has a case for "restartMcpServer"
   - Calls controller.mcpHub.restartConnection(message.text)
   - Updates servers state internally 

3. **Extension Sends Response**:
   - Controller calls `postMessageToWebview({type: "mcpServers", mcpServers: updatedServers})`
   - Webview receives the message in event listener

4. **Frontend Updates State**:
   - ExtensionStateContext's message handler processes "mcpServers" type
   - Updates React state with `setMcpServers(message.mcpServers)`
   - UI re-renders with new server data

### After Migration (gRPC Flow)

1. **Webview Initiates Action**:
   - User clicks a button in a React component
   - Component calls `McpServiceClient.restartMcpServer({serverName: serverName})`
   - Client wraps this in a generic `vscode.postMessage({type: "grpc_request", ...})`

2. **Extension Processes gRPC Request**:
   - Controller routes "grpc_request" to the gRPC handler
   - gRPC handler identifies service "cline.McpService" and method "restartMcpServer"
   - Calls corresponding handler function with request payload

3. **Handler Performs Operation**:
   - Handler function calls controller.mcpHub.restartConnection
   - Gets updated servers and converts to proto format
   - Returns response object

4. **Extension Sends gRPC Response**:
   - gRPC handler wraps response in a `grpc_response` message
   - Controller sends this to webview

5. **Frontend Resolves Promise**:
   - The original call `McpServiceClient.restartMcpServer()` resolves with response
   - Component directly updates state with `setMcpServers(convertProtoMcpServersToMcpServers(response.mcpServers))`
   - UI re-renders with new server data

This new flow eliminates the need for specific message type handlers in ExtensionStateContext and creates a more predictable, type-safe pattern for communication.

## Finding Examples

When migrating a message, look for similar existing implementations:

1. Search for other RPC methods in the same service directory
2. Look at the service's proto file for similar operation patterns
3. Examine conversion functions in the proto-conversions directory
4. Find components that use similar service calls

For example, when migrating an MCP-related message, look at:
- `/proto/mcp.proto` for similar RPC definitions
- `/src/core/controller/mcp/` for implementation patterns
- `/src/shared/proto-conversions/mcp/` for type conversion examples
- `/webview-ui/src/components/mcp/` for frontend usage patterns
